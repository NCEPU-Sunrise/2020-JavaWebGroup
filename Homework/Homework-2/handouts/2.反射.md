# 反射  
## 反射机制简介
在Java语言里面，之所以会有如此众多的开源技术支撑很大的一部分是来自于Java最大的特征———反射，如果不能灵活的去使用反射机制进行项目的开发与设计，那么就无法接触到Java的精髓所在。  
#### 反射能干什么？  
**重用性**    
反射机制最大的特征就是可以根据其自身的特点（Object类直接操作、可以直接操作属性或者方法）实现相同功能类的重复操作的抽象处理，解除程序的耦合问题。

#### 什么是反射？ 
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。  

对于反射技术我们首先考虑**反**与**正**的关系。  
所谓的**正操作**是指当我们要使用一个类时，一定要导入程序所在的包，而后在根据类进行对象的实例化，并且依靠对象调用类中的方法。**反**则是根据实例化对象反推出其类型。  
###### 范例
```
import java.util.Date;   // 1、导入程序所在的包.类,知道对象的出处

public class Test {
public static void main(String[] args) throws Exception {
    Date date = new Date() ;    // 2、通过类产生实例化对象
    System.out.println(date.getTime());     //3、根据对象调用类中的方法
}
``` 
实现反的处理操作，首先要采用Object类中所提供的一个操作方法：  
    · 获取Class对象信息：public final Class<?>getClass();  
    · getClass()方法可以帮助使用者找到对象的根源。
```
import java.util.Date;   // 1、导入程序所在的包.类,知道对象的出处

public class Test {
    public static void main(String[] args) throws Exception {
        Date date = new Date() ;    // 2、通过类产生实例化对象
        System.out.println(date.getClass());     //3、根据实例化对象获取对象的类型
    }
}
```  
## Class类对象的三种实例化模式(都要掌握)  
反射之中所有核心操作都是通过Class类对象展开的，可以说Class类是反射操作的根源所在。获取Class类的实例化对象，我们可以采用三种方式完成：  

1.【Object类支持】  
Object类可以根据实例化对象获取Class对象：public final Class<?> **getClass()**;  
不是缺点的缺点：如果只是想获得Class类对象，则必须产生指定类的对象
```
package Tutorial;

class Person{}   //自定义程序类

public class Test {
    public static void main(String[] args) throws Exception {
        Person per = new Person();    // 通过类产生实例化对象
        Class<Person> cls = per.getClass();
        System.out.println(cls.getName());    // 获取类的完整名称
    }
}
``` 
```
运行结果： 
package Tutorial;
```
2.【JVM直接支持】
任何数据类型（包括基本数据类型）都有一个“静态”的class属性   
缺点：需要导入类的包，依赖太强，不导包就抛编译错误。
```
package Tutorial;

class Person{}   //自定义程序类

public class Test {
    public static void main(String[] args) throws Exception {
        Class<Person> cls = Person.class;
        System.out.println(cls.getName()); 
    }   
}
```   
3. 【Class类支持】    
在Class里面提供有一个static方法：public static Class<?> **forName(String className)**
                        throws ClassNotFoundException  
```
public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls = Class.forName("java.util.Date");//解除与某一个类的耦合
        System.out.println(cls.getName());
    }
}

```    
这种模式最大的特点是可以直接采用字符串的形式定义要使用到的类型，并且程序中不需要编写任何的import语句。  
如果使用的程序类不存在则会抛出“java.lang.ClassNotFoundException”异常。  
## 反射实例化对象  
获取Class对象之后最大的意义实际上并不在于只是一个对象的实例化操作形式，更重要的是Class类里面提供有一个对象的反射实例化方法(代替了关键字new):  

* JDK1.9以前的实例化：**newInstance()**  
范例：  
```
package Tutorial;

class Person{
    public Person(){//无参构造方法
        System.out.println("***************Person类*************构造方法");
    }

    public String toString(){
        return "我是一个好人！"
    }
}   

public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls = Class.forName("Tutorial.Person");
        Object obj = cls.newInstance();//实例化对象，JDK1.9后被删除了
        System.out.println(obj);  //输出对象调用toString()方法
    }   
}
```  
```
运行结果： 
***************Person类*************构造方法
我是一个好人！
```  

现在通过反射实现的对象实例化操作，依然要调用类中的无参构造方法，其本质等价于“类 对象名 = new 类名()”,相当于隐含了关键字new，而直接使用字符串进行了替代。     

从JDK1.9之后newInstance()被替代了，原因是：默认的Class类中的newInstance()方法只能调用无参数的构造方法，所以很多开发者认为其描述得不准确，于是将其变化了形式： 

* JDK1.10的实例化：**getDeclaredConstructor().newInstance()**     
范例：  
```
package Tutorial;
class Person{
    String name;
    public Person(){//无参构造方法
        System.out.println("***************Person类*************无参构造方法");
    }
    public Person(String name){//有参构造方法
        System.out.println("***************Person类*************有参构造方法");
        this.name = name;
        System.out.println(this.name);
    }

    public String toString(){
        return "我是一个好人！";
    }
}   

public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls = Class.forName("Tutorial.Person");
        Object obj = cls.getDeclaredConstructor(String.class).newInstance("小明");//有参构造方法的实例化
        System.out.println(obj);  //输出对象调用toString()方法
    }   
}
```  
#### 在哪里使用？
Runtime类、Class类、Pattern类、Spring框架  
## 反射与类操作
在反射机制的的处理过程中不仅仅只是一个实例化对象的处理操作，更多的情况下还有类的组成结果操作，任何一个类的基本组成结构：父类（父接口）、包、属性、方法（构造方法、普通方法）。  
#### 获取类的基本信息  
* 类所在的包名称: 
    - public Package getPackage();   
    - public String getName();  
    ```
    Class<?> cls = Person.class;//获取指定类的Class对象
    Package pack = cls.getPackage();//获取指定类的包定义
    System.out.println(pack.getName());//获取包名称
    ```
* 继承的父类： 
    - public Class<? super T> getSuperclass();
    ```
    Class<?> cls = Person.class;//获取指定类的Class对象
    Class<?> parent = cls.getSuperclass();//获取父类定义（单继承）
    System.out.println("父类名："+parent.getName());
    ```  
* 实现的父接口：  
    - public Class<?>[] getInterfaces();
    ```
    Class<?> cls = Person.class;//获取指定类的Class对象
    Class<?> clazz[] = cls.getInterfaces();//可实现多个接口，用数组获取返回值
    for(Class<?> temp : clazz) {
        System.out.println("接口名："+temp.getName());
    }
    ```   
范例：
```
package Tutorial;

interface IMessageService{
    public void send();
}
interface IChannelService{
    public boolean connect();
}
abstract class AbstractBase {}
class Person extends AbstractBase implements IMessageService,IChannelService {

    @Override
    public boolean connect() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public void send() {
        System.out.println("信息发送");
        
    }   
}
public class Test{
    public static void main(String[] args) throws Exception {
        Class<?> cls = Person.class;//获取指定类的Class对象
        Package pack = cls.getPackage();//获取指定类的包定义
        System.out.println("包名："+pack.getName());//获取包名称
        
        Class<?> parent = cls.getSuperclass();//获取父类名称
        System.out.println("父类名："+parent.getName());
        
        Class<?> clazz[] = cls.getInterfaces();
        for(Class<?> temp : clazz) {
            System.out.println("接口名："+temp.getName());
        }
    }
}
```
```
运行结果:
包名：Tutorial
父类名：Tutorial.AbstractBase
接口名：Tutorial.IMessageService
接口名：Tutorial.IChannelService
```

当我们获取一个类的Class对象之后就意味着这个对象可以获取类之中的一切集成结构信息。   
#### 反射调用构造方法   
当我们在通过反射实例化对象的时候就已经接触到了构造方法的问题（getDeclaredConstructor().newInstance()）   

1.**通过Class实例的方法可以获取Constructor实例**：    

* 获取所有构造方法：
    - 获取所有public的Constructor
        + public Constructor<?>[] **getConstructors()** throws SecurityException  
    - 获取所有的Constructor
        + public Constructor<?>[] **getDeclaredConstructors()** throws SecurityException  
* 获取指定构造方法：
    - 获取指定的某个public的Constructor
        + public Constructor<T> **getConstructor**(Class<?>... parameterTypes) throws NoSuchMethodException,SecurityException   
    - 获取指定的某个Constructor
        + public Constructor<T> **getDeclaredConstructor**(Class<?>... parameterTypes) throws NoSuchMethodException,SecurityException 
        + 通过设置setAccessible(true)来访问非public构造方法。      

2.**通过Constructor实例可以创建一个实例对象**：**newInstance()**      
Object obj = constructor.newInstance();    
虽然程序代码本身允许开发者调用有参构造处理，但是使用反射的类中最好提供有无参构造，这样的实例化可以达到统一性。   
   
范例：
```
package Tutorial;

import java.lang.reflect.Constructor;

interface IMessageService{
    public void send();
}
interface IChannelService{
    public boolean connect();
}
abstract class AbstractBase {
    public AbstractBase() {}
    public AbstractBase(String msg) {}
}
class Person extends AbstractBase implements IMessageService,IChannelService {
    String name;
    int age;
    public Person(String name,int age) {
        this.name = name;
        this.age = age;
    }
    public Person() {}
 
    public boolean connect() {
        return true;
    }

    public void send() {
        System.out.println("信息发送");
    }   
}
public class Test{
    public static void main(String[] args) throws Exception {
        Class<Person> cls = Person.class;//获取指定类的Class对象
        Constructor<Person> constructor =  cls.getConstructor(String.class,int.class);
        Person per = constructor.newInstance("小强",12); 
        per.send();
    }
}
```
#### 反射调用普通方法
Java的反射API提供的Method对象封装了方法的所有信息：    
1.**通过Class实例的方法可以获取Method实例**：     

* Method getMethod(name, Class...)：获取某个public的Method（包括父类） 
* Method[] getMethods()：获取所有public的Method（包括父类）    
* Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）       
* Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）   

2.**通过Method实例可以获取方法信息**：   

* getName()  
* getReturnType()   
* getParameterTypes() 
* getModifiers()   

3.**通过Method实例可以调用某个对象的方法**：    

* Object invoke(Object instance, Object... parameters)；  
    - Method.invoke(obj,value);//obj为实例化对象        


范例：
```
package Tutorial;

import java.lang.reflect.*;

class Person  {
    private String name;
    public Person() {}
    
    private void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    
}
public class Test{
    public static void main(String[] args) throws Exception {
        Class<?> cls = Class.forName("Toturial.Person");//获取指定类的Class对象
        //Constructor<?> constructor =  cls.getConstructor(String.class,int.class);
        //Object obj =  constructor.newInstance("小强",12); 
        //Object obj =  cls.getConstructor(String.class,int.class).newInstance("小强",12);
        Object obj =  cls.getConstructor().newInstance();//1.实例化对象
        String setMethodName = "setName";//方法名称
        //获取Method实例
        Method setMethod = cls.getDeclaredMethod(setMethodName, String.class);
        setMethod.setAccessible(true);
        String value = "小强";
        //调用方法
        setMethod.invoke(obj,value);//等价于：Person对象.setName(value);
        
        String getMethodName = "getName";//方法名称
        Method getMethod = cls.getDeclaredMethod(getMethodName);
        System.out.println(getMethod.invoke(obj)); //等价于：Person对象.getName();
    }
}  
```  
此类操作整体的形式上不会有任何的明确的类对象产生，一切都是依靠反射机制处理的，这样的处理避免了与某一个类的耦合问题。（字符串，可以变）

#### 反射调用成员属性(Field)
Class类提供了以下几个方法来获取字段：      

* Field getField(name)：根据字段名获取某个public的field（包括父类）     
* Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）    
* Field[] getFields()：获取所有public的field（包括父类   
* Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）     

Field对象包含了一个字段的所有信息：     

* getName()：返回字段名称，例如，"name"；
* getType()：返回字段类型，也是一个Class实例，例如，String.class；
* getModifiers()：返回字段的修饰符      

Field类里面最为重要的操作方式并不是获取全部的成员，而是如下的三个方法：       

* 设置属性内容：public void set(Object obj,Object value)    
* 获取属性内容：public Object get(Object obj)    
* 解除封装：public void setAccessible(boolean flag)
范例：
```
package Tutorial;

import java.lang.reflect.*;

class Student extends Person {
    public int score;
    private int grade;
    public void Student(String name,int score,int grade) {
        this.name = name;
        this.score = score;
        this.grade = grade;
    }
    public Student() {}
}

class Person {
    public String name;
}

public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls = Student.class;//获取指定类的Class对象
        Object obj =  cls.getConstructor().newInstance();
        // 获取public字段"score":
        System.out.println(cls.getField("score"));
        // 获取继承的public字段"name":
        System.out.println(cls.getField("name"));
        // 获取private字段"grade":
        Field f = cls.getDeclaredField("grade");
        System.out.println(f);
        // 获取Field对象的基本信息
        System.out.println(f.getName());
        System.out.println(f.getType());
        System.out.println(f.getModifiers());
        //访问成员
        f.setAccessible(true);//解除封装，访问private变量
        f.set(obj, 100);
        Object value = f.get(obj);
        System.out.println(value);
        
    }
}
```        
## ClassLoader类加载器
## 反射与代理设计模式  
代理设计模式是程序开发中使用最多的设计模式，代理设计模式的核心是有真实业务实现类与代理业务实现类，并且代理类要完成比真实业务更多的处理操作。代理设计模式必须是基于接口的设计。
#### 静态代理设计 （后面不用）      
范例：
```
package Tutorial;

interface IMessage{  //传统代理设计必须有接口
    public void send();//业务方法
}
class MessageReal implements IMessage{//真实业务类
    public void send(){
        System.out.println("消息发送");
    }
}
class MessageProxy implements IMessage{  //代理类
    private IMessage message;//代理对象，一定是业务接口对象
    public MessageProxy(IMessage message) {
        this.message = message;
    }
    public void send(){
        if(this.connect()) {
            this.message.send();
            this.close();
        }
    }
    public boolean connect() {
        System.out.println("[消息代理]连接成功");
        return true;
    }
    public void close() {
        System.out.println("【消息代理】消息通过关闭");
    }
}
public class Test {
    public static void main(String[] args) throws Exception {
        IMessage msg = new MessageProxy(new MessageReal());
        msg.send();
    }   
}
```
特点：以上操作代码为一个最为标准的代理模式，但是我们发现一个代理类只为一个接口服务,所有这样的操作如果才能够实际开发来讲 最好再引入工厂设计模式进行代理对象的获取。

#### 动态代理设计   
从静态代理设计模式的缺陷可以发现，最好的做法是为所有功能一直的业务接口提供有统一的代理处理功能，可以通过动态代理机制来实现。在动态代理机制中需要考虑到如下几点问题：     

* 一定要接收真实业务实现子类对象     
* 由于动态代理类不再与某一个具体的接口进行捆绑，所以应该可以动态获取类的接口信息    
* InvocationHandler接口，这个接口规定了代理方法的执行     
* 进行动态代理设计的时候对于动态对象的创建是由JVM底层完成的，此时主要依靠的是java.lang.reflect.Proxy程序类，这个程序类中只提供有一个核心方法：public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h);    
    - ClassLoader loader :当前真实主体类的ClassLoader;   
    - Class<?>[] interfaces:代理是围绕接口进行的，所以一定要获取真实主体类的接口信息；    
    - InvocationHandler h：代理处理的方法    

范例：
```
package Tutorial;
import java.lang.reflect.*;

interface IMessage{  //传统代理设计必须有接口
    public void send();//业务方法
}
class MessageReal implements IMessage{
    public void send(){
        System.out.println("消息发送");
    }
}
class MLDNProxy implements InvocationHandler{
    private Object target;//保存真实业务对象
    public Object bind(Object target) {
        this.target = target;
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
        // 参数说明：
        // 参数1：指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器
        // 参数2：指定目标对象的实现接口
        // 即要给目标对象提供一组什么接口。若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法
        // 参数3：指定InvocationHandler对象。即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象
    }
    public boolean connect() {
        System.out.println("【消息代理】连接成功");
        return true;
    }
    public void close() {
        System.out.println("【消息代理】消息通过关闭");
    }
    
    //  复写InvocationHandler接口的invoke（）
    //  动态代理对象调用目标对象的任何方法前，都会调用调用处理器类的invoke（）
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("执行方法："+method);
        Object returnData = null;
        if(this.connect()) {
            returnData = method.invoke(this.target, args);
            this.close();
        }
        return returnData;
    }  

}

public class Test {
    public static void main(String[] args) throws Exception {
        IMessage msg = (IMessage) new MLDNProxy().bind(new MessageReal());
        msg.send();
    }   
}
```   
所有的代理类是符合所有相关功能需求的操作功能类，它不再代表具体的接口，这样在处理的时候就必须依赖与类加载器与接口进行代理对象的伪造。    
## 反射应用案例  

#### 反射与工厂设计模式
如果要实现对象的实例化处理，可以使用关键字new,还可以使用反射机制来完成。为什么要提供一个反射的实例化？使用关键字new还是使用反射呢？  
工厂设计模式的最大特点是客户端的程序类不直接牵扯到对象的实例化管理，只与接口发生关联，通过工厂类获取指定接口的实例化对象。   
```
package Tutorial;

interface IMessage{
    public void send();//消息发送
}

class NetMessage implements IMessage{
    public void send(){
        System.out.println("网络消息发送");
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        IMessage msg = new NetMessage();   //如果直接实例化则一定会有耦合问题（实现这个接口的类不止一个）
    }   
}
``` 
在实际的开发中，接口的主要作用是为不同的层提供有一个操作的标准，但是如果此时直接讲一个子类设置为接口实例化操作，那么一定会有耦合问题，所以使用工厂设计模式来解决此问题。  
范例：利用工厂设计模式解决
```
package Tutorial;

interface IMessage{
    public void send();//消息发送
}
class NetMessage implements IMessage{
    public void send(){
        System.out.println("网络消息发送");
    }
}
class CloudMessage implements IMessage{
    public void send(){
        System.out.println("云消息发送");
    }
}
class Factory {
    private Factory() {} //没有产生实例化对象的意义，所以构造方法私有化
    public static IMessage getInstance(String className) {  //静态方法
        if("netmessage".equalsIgnoreCase(className)) {
            return new NetMessage();
        } else if("cloudmessage".equalsIgnoreCase(className)) {
            return new CloudMessage();
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        IMessage msg = Factory.getInstance("netmessage");
        msg.send();
        IMessage msgB = Factory.getInstance("cloudmessage");
        msgB.send();
    }   
}

``` 
```
运行结果： 
网络消息发送
云消息发送
```     
工厂设计模式示意图：  
![Alt text](http://m.qpic.cn/psc?/V50n1dGd3Doigx0hCE5i1cHBhY4Ug0Hs/ruAMsa53pVQWN7FLK88i5igmS61V*yU7BKlEUFyyYBU9*QLKS9eHFieuKboHhHEGH9jo9RFIi8mcHRzekLhvv5eH9ARGEHVJHXBKePVq5D4!/mnull&bo=9AQEAgAAAAADB9Q!&rf=photolist&t=5 "工厂设计模式")  
缺点：此种工厂模式属于静态工厂设计模式，如果要追加一个子类，则工厂类要做出修改。  

工厂设计模式最有效解决的是子类和客户端的耦合问题，但是解决的核心思想是在于提供有一个工厂类来作为过渡端，但是随着项目的进行，IMessage可能有更多的子类，此时工厂类要随之修改，这时最好的解决方案就是不使用关键字new来完成，因为new在使用是需要有一个明确的类存在。而newInstance()方法只需要有一个字符串的类名作为参数,。  
修改后的程序：
```
package Tutorial;

interface IMessage{
    public void send();//消息发送
}
class NetMessage implements IMessage{
    public void send(){
        System.out.println("网络消息发送");
    }
}
class CloudMessage implements IMessage{
    public void send(){
        System.out.println("云消息发送");
    }
}
class Factory {
    private Factory() {} //没有产生实例化对象的意义，所以构造方法私有化
    public static IMessage getInstance(String className) {  //静态方法
        IMessage instance = null;
        try {
            instance = (IMessage)Class.forName(className).getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return instance;
    }
}
public class Test {
    public static void main(String[] args) throws Exception {
        IMessage netMsg = Factory.getInstance("Tutorial.NetMessage");//包名.类名（名称要写对，大小写敏感）
        IMessage cloudMsg = Factory.getInstance("Tutorial.CloudMessage");
        netMsg.send();
        cloudMsg.send();
    }   
}
```
```
运行结果:
网络消息发送
云消息发送
```  
![Alt text](http://a1.qpic.cn/psc?/V50n1dGd3Doigx0hCE5i1cHBhY4Ug0Hs/ruAMsa53pVQWN7FLK88i5g6.Z5od550uCZaIlF*PRHMW6Ca60g9djuqoC1TExUHTRyY*CLRdcgbirBJA5ndBaJ8wS*IyTW6opDCk.eQL8fU!/c&ek=1&kp=1&pt=0&bo=oAVWAgAAAAADJ*M!&tl=1&vuin=2386884662&tm=1611298800&sce=60-2-2&rf=0-0)  
Fatory与子类之间没有直接的联系，使工厂的设计实现多态。  

前面的讨论解决了两个问题：

* 接口对象实例化的耦合问题---提出Factory设计模式
* 接口的动态扩充问题---弃用new关键字，使用newInstance()反射机制  
但是我们需要进一步思考的是实际开发中可能存在大量的接口,并且这些接口都可能需要通过工厂类实例化，因此工厂类不应该只为IMessage接口服务，而应该为所有接口服务。  
```
package Tutorial;

interface IMessage {
    public void send();//消息发送
}
interface IService {
    public void service();
}
class HouseService implements IService {
    public void service() {
        System.out.println("为您的住宿提供服务");
    }
}
class NetMessage implements IMessage{
    public void send(){
        System.out.println("网络消息发送");
    }
}

class Factory {
    private Factory() {} //没有产生实例化对象的意义，所以构造方法私有化
    /**
     * 获取接口实例化对象
     * @param className 接口的子类
     * @param clazz 接口的类型
     * @return 如果子类存在则返回指定接口实例化对象
     * */
    public static<T> T getInstance(String className,Class<T> clazz) {  //泛型一定要有，将所有的IMessage替换为T;增加一个参数
        T instance = null;
        try {
            instance = (T)Class.forName(className).getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return instance;
    }
}
public class Test {
    public static void main(String[] args) throws Exception {
        IMessage netMsg = Factory.getInstance("Tutorial.NetMessage",IMessage.class);//包名.类名（名称要写对，大小写敏感）
        netMsg.send();
        IService service = Factory.getInstance("Tutorial.HouseService",HouseService.class);//包名.类名（名称要写对，大小写敏感）
        service.service();
    }   
}
```
![Alt Text](http://m.qpic.cn/psc?/V50n1dGd3Doigx0hCE5i1cHBhY4Ug0Hs/ruAMsa53pVQWN7FLK88i5vgydDVOEJtHIUzAs7e7mxbFyBUJ9TWGPK2.XyvgM5o2SWe.DWNe8UCS4PMhPeVMiy7rPx9IrpQpmlx0FVd5nYo!/mnull&bo=yQVLAgAAAAADB6c!&rf=photolist&t=5)  
此时的工厂设计模式将不再受限于指定的接口，可以为所有的接口提供实例化服务，实现可重用性。  

## 反射与单例设计模式 
单例设计模式最大的特点就是在整体的运行过程中只允许产生一个实例化对象。    
单例设计模式的本质在于：类内部的构造方法私有化，在类的内部产生类的实例化对象之后通过static方法获取实例化对象，进行类中的结构调用。  
单例设计模式一共有两类：懒汉式、饿汉式。本节课主要讨论懒汉式的单例设计模式。  
范例：观察懒汉式的程序设计模式  
```
package Tutorial;

class Singleton {
    public static Singleton instance = null;//声明对象
    
    private Singleton() {//无参构造
        System.out.println("【"+Thread.currentThread().getName()+"】*****实例化Singleton对象*****");
    } 
    
    public void print() {
        System.out.println("懒汉式单例设计模式");
    }
    public static Singleton getInstance() {//实例化对象
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        for(int i = 0;i < 3; i++) {
            new Thread(()->{
                Singleton sinA = Singleton.getInstance();
                sinA.print();
            },"单例消费端-"+i).start();
        }
        
    }   
}
```
```
运行结果（不唯一）：  
【单例消费端-0】*****实例化Singleton对象*****
【单例消费端-1】*****实例化Singleton对象*****
懒汉式单例设计模式
【单例消费端-2】*****实例化Singleton对象*****
懒汉式单例设计模式
懒汉式单例设计模式
```  
当有若干线程之后，程序就可以产生多个实例化对象，此时就不是单例设计模式。此时问题的关键在于代码本身出现了不同步的情况，**解决的核心在于同步处理（synchronized）**。  
进行同步处理后的代码：  
```
public static volatile Singleton getInstance() {//实例化对象
        if(instance == null) {//第二次再执行时，instance已经不为空了
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }  
        }
        return instance;
}
```  
```
运行结果：
【单例消费端-0】*****实例化Singleton对象*****
懒汉式单例设计模式
懒汉式单例设计模式
懒汉式单例设计模式
```  
修改后的代码是**标准的单例设计模式**。

## 反射与泛型

* Class<?> cls = Class.forName("java.util.Date");  //JVM支持Class对象实例化 
* Class<Person> cls = Person.class;   //JVM支持Class对象实例化
* public Class<? super T> getSuperclass();//获取继承的父类   
* public Class<?>[] getInterfaces();//获取实现的所有父接口    
* public Constructor<?>[] **getDeclaredConstructors()** throws SecurityException //获取所有构造方法
* public Constructor<T> **getDeclaredConstructor**(Class<?>... parameterTypes)//获取指定构造方法    

#### 泛型数组
借助Class<T>来创建泛型数组：
```
T[] createArray(Class<T> cls) {
    return (T[]) Array.newInstance(cls, 5);
}
```
示例：
```
import java.lang.reflect.*; 
class asArray<T> {
    private T[] array;
    
    @SuppressWarnings("unchecked")
    T[] createArray(Class<T> type, int sz) {
        return array = (T[]) Array.newInstance(type, sz);//通过反射在运行时构出实际类型为type[]的对象数组，避免了类型擦除，从而转换成功，无ClassCastException
    }
    public void put(int index, T item){
        array[index] = item;
    }
    public T get(int index) { return array[index]; }
    
}
class Test{
    public static void main(String[] args) {
        asArray<String> gArray = new asArray<String>();
        String[] array = gArray.createArray(String.class, 5);
        gArray.put(0, "Hello");
        for(String x : array) {
            System.out.println(x);
        }
    }

```
