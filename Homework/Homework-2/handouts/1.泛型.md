# 泛型
泛型从JDK1.5之后追加到Java语言中，其主要的目的是为了解决ClassCastException的问题。当进行对象的向下转型时都可能存在安全隐患，而Java希望通过泛型可以慢慢解决掉此类问题。    
## 泛型的问题引出
现在假设定义一个x，y坐标的处理类，并而在这个类中允许开发者保存三类数据：   

* 整型数据：x = 10,y = 20
* 浮点型数据：x = 10.1,y = 20.9
* 字符串数据：x = 东经120度,y = 北纬30度   

于是在设计Point类的时候就需要去考虑具体的x和y属性的类型，这个类型要求可以保存以上三种数据，很明显最方便的做法就是利用Object类来定义，因为存在如下的转型关系：   

* 整型数据：基本数据类型->包装为Integer类对象->自动向上转型为Object
* 浮点型数据：基本数据类型->包装为Double类对象->自动向上转型为Object   
* 字符串数据：String类对象->自动向上转型为Object   

###### 范例：   
```
package Tutorial;
class Point {
    private Object x;
    private Object y;
    public void setX(Object x) {
        this.x = x;
    }
    public void setY(Object y) {
        this.y = y;
    }
    public Object getX() {
        return this.x;
    }
    public Object getY() {
        return this.y;
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        Point point = new Point();
        //第一步：根据需求进行内容设置
        point.setX(10);  //自动装箱
        point.setY(20);  //自动装箱
        //第二步：从里面获取数据
        int x = (Integer)point.getX();
        int y = (Integer)point.getY();
        System.out.println("x坐标："+x+",y坐标："+y);
    }   
}
```     
本程序之所以可以解决当前的设计问题，主要的原因在于，Object可以接收所有的数据类型，但是正因为如此，也会出现严重的安全隐患。    
将内容设置代码改为：`point.setY("北纬20度");` 
在程序编译的时候实际上是不会有任何的错误产生，而执行时会产生 java.lang.ClassCastException异常。
## 泛型基本定义
如果要想避免程序中出现“ClassCastException”最好的做法是可以直接回避掉对象的强制转换。在JDK1.5之后提供有泛型技术，而泛型的本质在于，**类中的属性或方法的参数与返回值类型可以由对象实例化的时候动态决定**。那么此时就需要在类定义的时候明确地定义占位符（泛型标记）。    

修改Point类（将Object替换为T，定义为泛型类）：      
```
package Tutorial;
class Point <T> {//T是Type的简写，可以定义多个泛型
    private T x;
    private T y;
    public void setX(T x) {
        this.x = x;
    }
    public void setY(T y) {
        this.y = y;
    }
    public T getX() {
        return this.x;
    }
    public T getY() {
        return this.y;
    }
}
```     
此时Point类中的x和y属性的数据类型并不确定，而是由外部来决定。     

提示：关于默认的泛型类型   

* 由于泛型是JDK1.5之后的产物，但是在这之前已经有不少内置的程序类或者接口广泛地应用在项目开发中，于是为了保证这些程序类或者接口追加了泛型之后依然可以使用，所以如果不设置泛型类型时，将自动使用Object作为类型，但是在编译的过程中会出现警告信息。     

泛型定义完成后可以在实例化对象的时候进行泛型的设置，一旦设置之后，里面的x和y的类型就与当前对象直接绑定了。      

修改测试类： 1.实例化对象的时候进行泛型的设置；2. 获取数据时不再向下转型
```
public class Test {
    public static void main(String[] args) throws Exception {
        Point<Integer> point = new Point<Integer>();
        //第一步：根据需求进行内容设置
        point.setX(10);  //自动装箱
        point.setY("北纬20度");
        //point.setY(20);  //自动装箱
        //第二步：从里面获取数据
        int x = point.getX();
        int y = point.getY();
        System.out.println("x坐标："+x+",y坐标："+y);
        
    }   
}
```    
出现编译时错误：`The method setY(Integer) in the type Point<Integer> is not applicable for the arguments (String)`      
内容设置为正确的数据后可正常输出。    

现在的程序代码之中，由于Point类里面设置的泛型类型为Integer,这样所有的对应次泛型的属性、变量、方法返回值都全部替换为Integer(只局限于此对象之中),这样我们在处理的时候如果发现设置的内容有错误，则会在程序编译的时候进行错误提示，同时也避免了对象的向下转型（可以避免安全隐患）。    
##### 泛型的使用注意点：

* 泛型之中只允许设置引用类型，如果要操作基本类型必须使用包装类(例如integer);    
* 从JDK1.7开始，泛型对象实例化可以简化为：`Point<Integer> point = new Point<>();`  

使用泛型可以解决大部分的类对象的强制转换处理，这样的程序才是一个合理的设计。      

## 泛型通配符
虽然泛型帮助开发者解决了一系列的对象的强制转换所带来的安全隐患，但是从另外一个角度来讲，泛型也带来了一些新的问题：引用传递处理。   
范例：观察问题的产生
```
package Tutorial;

class Message <T>{
    private T content ;
    public void setContent (T content) {
        this.content = content ;
    }
    public T getContent() {
        return this.content ;
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        Message<String> msg = new Message<>();
        msg.setContent("HelloWorld!");
        fun(msg);
    }
    public static void fun(Message<String> temp){
        System.out.println(temp.getContent());
    } 
//    public static void fun(Message temp){
//      temp.setContent(1.1);
//      System.out.println(temp.getContent());
//  } 
}
```      
但是这个时候问题也就出现了，而问题的关键在于fun()方法，如果真的去使用，泛型不可能只是一种，也就是说fun()方法应该可以接收任意种泛型类型的Message对象。如果不设置泛型，虽然程序可以运行了，但是会出现更为严重的情况---方法中有可能对数据进行修改。所以此时需要找一种方案：可以接收所有的泛型类型，并且不能够修改里面的数据（允许获取），我们通过通配符**？**来解决。   

范例：使用通配符
```
public static void fun(Message<?> temp){
    //temp.setContent(1.1);//编译时错误：The method setContent(capture#1-of ?) in the type Message<capture#1-of ?> is not applicable for the arguments (double),即加了通配符之后不允许修改数据
    System.out.println(temp.getContent());
} 
```
后面我们在使用时，当不确定泛型类型时使用？来占位。     

在？这个通配符的基础之上实际上还提供有两类小的通配符：     

* ?extends 类：设置泛型的上限;
    - 例如：定义**？extends Number**:表示该泛型类型值允许设置Number或Number的子类；
* ?super 类：设置泛型的下限：
    - 例如：定义**?super String**:只能使用String或其父类;

对于通配符而言是一个重要的概念，要求大家理解此概念的定义，日后在学习Java的一些系统类库的时候回见到大量的通配符使用。  
## 泛型接口  
泛型除了在类上定义之外还可以直接在接口中使用。   
```
interface IMessage<T> {
    public String echo(T t);
}
```    
对于泛型接口的子类而言现在就有两种实现方式:    

* 在子类中继续设置泛型定义
```
class MessageImpl<S> implements IMessage<S> {
    public String echo (S t){
        return "【ECHO】" +t ;
    }
}
```
```
public class Test {
    public static void main(String[] args) throws Exception {
        IMessage<String> msg = new MessageImpl<String>() ;
        System.out.println(msg.echo("HelloWorld!"));
    }   
}
```    
* 在子类实现父接口的时候直接定义出具体泛型类型     
```
class MessageImpl implements IMessage<String> {
    public String echo (S t){
        return "【ECHO】" +t ;
    }
}
```
```
IMessage<String> msg = new MessageImpl() ;
System.out.println(msg.echo("HelloWorld!"));

```    
## 泛型方法
在之前的程序类中实际上已经可以发现在泛型类中如果可以将泛型标记写在方法上，那么这样的方法就被称为是泛型方法。但是需要注意的是，泛型方法不一定非要出现在泛型类之中。     
```
public class Test {
    public static void main(String[] args) throws Exception {
        Integer num[] = fun(1,2,3);//传入了整数，则泛型类型就是Integer
        for(int i : num) {
            System.out.print(i + "  ");
        }
        System.out.print(func(num[2]));
    }  
    public static <T>T[] fun(T ...args) {//泛型方法
        return args;
    }
    public static <T>T func(T t) {//泛型方法
        return t;
    }
}
```
在后期进行项目开发的时候，这种泛型方法很常见，比如工厂设计模式。后面在讲反射时会讲。     


