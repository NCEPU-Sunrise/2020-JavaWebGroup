# 常见类

## Vector 向量

### 1.所属类包：

​	`java.util`

### 2.用处：

它是允许不同类型元素共存的变长数组，需要做频繁的查询、插入或删除等操作

### 3.构造函数： 

```java
Vector()
    //构造一个长度为10的空向量。
Vector(int capacity)
    //  以指定的存储容量构造一个空向量。
Vector(int capacity, int capacityIncrement)
    //以指定的存储容量和容量增量构造一个空向量。
```

#### ·创建向量：

```java
Vector<·> MyVector=new Vector<·>(100,50)；
    //创建的MyVector向量序列初始有100个元素的空间，以后一旦使用殆尽则以50为单位递增，使序列中元素的个数变化成150，200，…
    //在创建Vector序列时，不需要指明序列中元素的类型（String、Integer...），可以在使用时确定。
```

#### ·添加元素

```java
1.addElement( Object obj)
  //将新元素添加到序列尾部。
2.insertElementAt(Object obj, int index)
  //将新元素插入到指定位置。
```

##### 	案例：

```java
import java.util.*; 
class Aa{
 public static void main(String [] arg) { 
	Vector MyVector=new Vector();
 	for (int i=1;i<=10;i++)
        	MyVector.addElement(new Integer(i));
    MyVector.insertElementAt("middle",5);
    for (int i=0;i<=10;i++)
      	System.out.println(MyVector.elementAt(i)); //输出向量
  }
}
//1
//2
//3
//4
//5
//middle
//6
//7
//8
//9
//10

```

#### ·查询元素

```java
Object elementAt(int index)
   //返回指定位置处的元素。
   //由于返回的是Object类型的对象，在使用之前通常需要进行强制类型转换，将返回的对象引用转换成Object类的某个具体子类的对象。例如：
   //String str=(String)MyVector.elementAt(0);
boolean contains(Object obj)
   //检查向量序列中是否包含指定的对象元素obj。
int indexOf (Object obj,int start_index)
   //从指定的start_index位置开始向后搜索，返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回－1。
int lastIndexOf(Object obj,int start_index)
   //从指定的start_index位置开始向前搜索，返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回－1。

```

##### 	案例：

```java
int i=0;
While ( (i=MyVector.indexOf(“welcome”,i))!=-1 )
{    System.out.println(i); 
      i++;
}

```

#### ·修改、删除

```java
setElementAt(Object obj,int index)
  //将index位置处的对象元素设置为obj，如果这个位置原来有元素,则被覆盖。
removeElement(Object obj)
  //删除与指定的obj对象相同的第一个元素，同时将后面的元素前提，补上空位。返回值是布尔值。
removeElementAt(int index)
  //删除index指定位置处的元素，将后面的元素前提。
removeAllElements()
  //清除序列中的所有元素。
```

##### 	案例：

```java
Vector MyVector = new Vector(100);
for (int i=0;i<10;i++)
{
    MyVector.addElement(“welcome”);
    MyVector.addElement(“to”);
    MyVector.addElement(“beijing”);
}
while (MyVector.removeElement(“to”));
```

#### ·其他方法

```java
size()：//返回Vector中元素的数量
capacity()：//返回Vector的容量                            
clone()：//建立Vector的备份
copyInto(Object[])：//把Vector中的元素拷贝到一个数组中
firstElement()：//返回第一个元素
lastElement()：//返回最后一个元素
isEmpty()：//判断是否为空
setSize(int size)：//设置Vector的大小
trimToSize()：//将Vector的容量下调至最小值             
```

### ·综合案例：

用向量实现，创建3个学生对象（学号、姓名、年龄）和4个教师对象（教工号、姓名、系别），并且输出。

```java
import java.util.*;
class Stu{
         String  xh, xm;	
	     int nl;
         public Stu(String xh1,String xm1,int nl1){
	         xh=xh1;xm=xm1;nl=nl1;
	     }
         void disp(){
	         System.out.println("学生："+xh+"  "+xm+"  "+nl);
	     }	
}
class Tech{
	  String gh, xm, xb;
      public Tech(String gh1,String xm1,String xb1){
              gh=gh1;xm=xm1;xb=xb1;	
      }
      void disp(){
              System.out.println("教师："+gh+"  "+xm+"  "+xb);
      }
}
public class StuTer{
	   public static void main(String[] s){
		Vector st=new Vector();
		st.addElement(new Stu("101","李明",18));
		st.addElement(new Stu("102","王大力",20));
		st.addElement(new Stu("103","刘萍",19));
		st.addElement(new Tech("10100","林小利","计算机"));
		st.addElement(new Tech("10101","熊平","计算机"));
		st.addElement(new Tech("10102","戴红兵","电力"));
		st.addElement(new Tech("10103","曲小军","电力"));
          for(int i=0;i<st.size();i++) {
                 if((st.elementAt(i)) instanceof  Stu)
                            ( (Stu)(st.elementAt(i)) ).disp();
                 else     ( (Tech)(st.elementAt(i)) ).disp();}
        }
}
```

![](C:\Users\17159\AppData\Roaming\Typora\typora-user-images\image-20210123203125797.png)

---

## ArrayList

### 1.所属类包：

​	`java.util`

### 2.用处：

在`ArrayList`内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，`ArrayList`会在内存中分配更大的数组来存储这些元素。

### 3.ArrayList类与Vector类的区别:

(1)`Vector`类是可同步化的，即任何操作`Vector`类的内容的方法都是线程安全的。但`ArrayList`类是不可同步化的，不是线程安全的。

(2)当数组容量不能满足要求时，两者扩展容量不同。`Vector`类在默认情况下是扩展一倍的大小，而`ArrayList`类扩展一半的大小。

### 4.构造函数：

```java
public ArrayList()
  //以默认容量构造一个ArrayList对象
public ArrayList (int capacity)
  //以指定的存储容量构造一个ArrayList对象
```

#### ·添加元素

```java
public boolean add(E element)
  //将指定的元素添加到此列表的尾部，添加成功返回true，失败返回false，其中E表示类型参数
public void add(int index, E element)
  //将指定的元素插入列表中的指定位置
public boolean addAll(int index, Collection c)
  //从index位置开始，将collection 中的所有元素插入到列表序列中
```

##### 	案例：

```java
import java.util.*; 			
public class App3_27 {
	public static void main(String[] args) {
		ArrayList myList = new ArrayList(); 	        // 创建列表对象
		for (int i = 1; i <= 4; i++)
			myList.add("" + i);		// 添加元素
		myList.add(2, "middle"); // 插入新元素
		for (int i = 0;i<myList.size();i++)
		System.out.print(myList.get(i)+" ");
	}
}
//1 2 middle 3 4
```

#### ·修改、删除元素

```java
public E set(int index, E element)
  //用指定元素替代列表中指定位置上的元素，返回值为原来位于指定位置上的元素
public boolean remove(Object o)
  //移除列表中首次出现的指定元素，如果列表不包含此元素，则列表不做改动
public E remove(int index)
  //移除列表中指定位置的元素，返回从列表中移除的元素
public void clear()
  //移除列表中的所有元素，此调用返回后，列表将为空
```

##### 	案例：

```java
import java.util.*;
public class App3_28 {
	public static void main(String[] args) {
		ArrayList myList = new ArrayList(); 
        // 创建列表对象
		for (int i = 0; i < 2; i++) { 		
            // 添加元素
			myList.add("welcome");
			myList.add("to");
			myList.add("beijing");
		}
		// 输出列表中所有元素
		System.out.println("未删除前列表：");
		for (int i = 0; i < myList.size(); i++)
			System.out.println(myList.get(i)+" ");
//
        		System.out.println("\n删除所有to之后的列表：");
		while (myList.remove("to"));	// 删除列表中所有的"to"元素
		for (int i = 0; i < myList.size(); i++)
			System.out.println(myList.get(i)+" ");				                           System.out.println("\n删除下标为2的元素之后的列表：");
		        myList.remove(2); 	// 删除列表中下标位置为2的元素
		for (int i = 0; i < myList.size(); i++)
			System.out.println(myList.get(i)+" ");		
	}
}	


```

#### ·查找元素

```java
public E get(int index)
//返回列表中指定位置上的元素
public boolean contains(Object o)
//如果列表中包含指定的元素，则返回true，否则返回false
public int indexOf(Object o)
//返回列表中首次出现的指定元素的位置，如果列表不包含元素，则返回-1
public int lastIndexOf(Object o)
//返回列表中最后一次出现的指定元素的位置，如果此列表不包含索引，则返回 -1
```

##### 	案例：

```java
import java.util.*;
public class App3_29 {
	public static void main(String[] args) {
		ArrayList myList = new ArrayList(); // 创建列表对象
		for (int i = 0; i < 2; i++) { 	// 添加元素
			myList.add("welcome");
			myList.add("to");
			myList.add("beijing");
		}
		String s = (String) myList.get(1); 				// 访问下标位置为1的元素
		System.out.println(s);
		System.out.println(myList.contains("to"));                                                		// 判断列表是否包含to
		int index = myList.lastIndexOf("welcome"); 			System.out.println(index);
	}}
//to
//true
//3
```

#### ·其他方法

```java 
public Object clone()
//建立列表的副本
public boolean isEmpty()
//判断列表是否为空
public int size()
//返回此列表中的元素数
public void trimToSize()
//将列表的容量下调至最小值
```

---

## 包装类

### 1.定义：

Java中的基本数据类型不是对象，有时使用不便，为了解决这个问题，Java语言为每个基本数据类型设计了一个对应的类，称为`包装类`。

| **基本数据类型** | **包装类** | **基本数据类型** | **包装类** |
| ---------------- | ---------- | ---------------- | ---------- |
| **byte**         | Byte       | boolean          | Boolean    |
| **short**        | Short      | char             | Character  |
| **int**          | Integer    | float            | Float      |
| **long**         | Long       | double           | Double     |

### 2.自动装箱：

把基本数据类型转换为对应的包装类类型

### 3.自动拆箱：

把包装类类型转换为对应的基本数据类型

#### 	案例：

```java
Integer i = 100;  // 自动装箱(只要是对象，在使用前就必须进行不为 null 的判断)
i += 200;        // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱
```

### 4.基本数据类型与包装类的不同点：

- 基本数据类型变量不是对象，包装类对象是对象。
- 创建方式不同：基本数据类型变量不需通过new来创建，包装类对象必须使用new创建。
- 存储方式及位置不同：基本数据类型变量直接存储变量的值保存在栈空间，包装类对象需要通过引用指向实例，具体的实例保存在堆空间中。
- 初始值不同：包装类对象的初始值为null，基本数据类型变量的初始值视具体的类型而定。
- 使用方式不同：比如与集合类联合使用时只能使用包装类。

### 5.其他：

具体的包装类可以由基本数据类型的大写在API中查询所属类有关的成员方法。

---

## Date类

### 1.所属类包：

​		` java.util`

### 2.定义：

​	`Date` 代表了一个特定的时间，精确到毫秒

### 3.构造函数：

基本上都过时，不会使用,了解以下几个就可以

```java
Date()
    //分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。
Date(long date)
    //分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。
```

案例：

```java
import java.util.Date;
public class TestDate {
    public static void main(String[] args) {
        // 当前时间
        Date d1 = new Date();
        System.out.println("当前时间:"d1);
        //Tue May 31 10:36:25 CST 2016
        // CST:China Standard Time
    
        date d2 = new Date(5000);
        System.out.println("从1970年1月1日 早上8点0分0秒 开始经历了5秒的时间"+d2);
        //Thu Jan 01 08:00:05 CST 1970
    }
}
```

### 4.其他方法：

```java
public long getTime()
  //获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值
public void setTime(long time)
  //设置时间，给的是毫秒值
pubic void toString()
  //把此 Date 对象转换为以下形式的 String： 星期 月份 日期 几时：几分：几秒 CST 年份
```

案例：

```java 
import java.util.Date;
        //注意：是java.util.Date;
        //而非 java.sql.Date，此类是给数据库访问的时候使用的
public class TestDate {
    public static void main(String[] args) {
        Date now= new Date();  
        long time=now.getTime();
        //当前时间返回的值getTime() 得到一个long型的整数:1464749767875
        time+=60*60*24*1000;
        //增加一天所经历的毫秒数
        date.setTime(time);            
        //输出明天此时此刻的日期和时间
        System.out.println(date);
        Date d2 = new Date(0);
        System.out.println(d2.toString());
        //标准时间：Thu Jan 01 08:00:00 CST 1970
    }
}
```

---

## SimpleDateFormat类

### 1.所属类包：

`java.text`

### 2.定义：

`DateFormat`本身是一个抽象类，`SimpleDateFormat`类是`DateFormat`类的子类，因为`DateFormat`的格式化date的功能有限，没有`SimpleDateFormat`强大，所以`DateFormat`类很少直接使用，一般都使用`SimpleDateFormat`类完成。`SimpleDateFormat `是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。

### 3.构造函数：

```java
public SimpleDateFormat()
  //构造一个SimpleDateFormat，使用默认模式和日期格式
public SimpleDateFormat(String pattern)
  //构造一个SimpleDateFormat使用给定的模式和默认的日期格式
```

参数中对应的字符意义如下：

y：年

M：月

d：日

HH：时

m：分

s：秒

S: 毫秒

E: 星期

#### ·格式化

(从**Date**到 **String** )

```java
public final String format(Date date)：
    //将日期格式化成日期/时间字符串
```

##### 案例：

```java
	Date date = new Date();
	//创建一个Date对象
    SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS E");//年份4位-月份2位-日期2位 小时2位:分钟2位:秒钟2位:毫秒3位 星期
	String strdate = a.format(date);
	//格式化，按指定格式
	System.out.println(strdate);
	//2021-01-23 22:47:27:000 星期六
```

#### ·解析日期

(从 **String** 到 **Date **)

 ```java
public Date parse(String source)：
    //从给定字符串的开始解析文本以生成日期
    //注意：调用SimpleDateFormat对象的parse()方法时可能会出现转换异常，及ParseException，因此需要进行异常处理
 ```

##### 案例：

```java
	String day = "2017年03月27日 16:02:30";
    SimpleDateFormat d = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
    try{
        Date date = d.parse(day);
        System.out.println(date);
        //Mon Mar 27 16:02:30 CST 2017
    } catch (ParseException e) {
        System.out.println(e.getMessage());
    }
}
```

---

## Calendar类

### 1.所属类包：

​	`java.util`

### 2.定义：

​		`Date`类最主要的作用就是获取当前时间，同时这个类里面也具有设置时间以及一些其他功能，但由于类本身设计的问题，不建议使用，推荐使用抽象类`Calendar`类进行日期和时间的处理。

### 3.常用方法：

```java
static Calendar getInstance() 
    //获取一个 Calendar对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance();
public int get(int field)
	//返回给定日历字段的值
public abstract void add(int field, int amount)
	//根据日历的规则，将指定的时间量添加或减去给定的日历字段
public final void set(int year,int month,int date)
	//设置当前日历的年月日
Date getTime()
    //返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象
```

##### 案例：

```java
import java.util.Calendar;
import java.util.Date;

public class Demo {
    public static void main(String[] args) {
        Calendar c = Calendar.getInstance();
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH) ;
        int day = c.get(Calendar.DAY_OF_MONTH);
        //一个月中的某一天
        int hour = c.get(Calendar.HOUR_OF_DAY);
        //一天中的某一个小时
        int minute =  c.get(Calendar.MINUTE);
        int second = c.get(Calendar.SECOND);
        System.out.println("现在的时间是：" + year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second);
---------------------------------------------------------------------------- 
        c.set(Calendar.YEAR, 2008);
        // 将月设置为 10
        c.set(Calendar.MONTH, 10);
        // 将日期设置为 3
        c.set(Calendar.DAY_OF_MONTH, 3);
        System.out.println(
                "年：" + c.get(Calendar.YEAR) + "\n" +
                "月：" + c.get(Calendar.MONTH) + "\n" +
                "一个月中的某一天：" + c.get(Calendar.DAY_OF_MONTH));
            //年：2008
			//月：10
			//一个月中的某一天：3
---------------------------------------------------------------------------- 
        c.add(Calendar.YEAR, -2);
             // 把年减少两年
        c.add(Calendar.MONTH, 3);
             // 把月份增加三个月
        c.add(Calendar.DAY_OF_MONTH, 10);
            // 把日期增加10天
        System.out.println(
                "年：" + c.get(Calendar.YEAR) + "\n" +
                "月：" + c.get(Calendar.MONTH) + "\n" +
                "一个月中的某一天：" + c.get(Calendar.DAY_OF_MONTH));
        //年：2006
		//月：1
		//一个月中的某一天：31
----------------------------------------------------------------------------
        System.out.println(calendar.getTime());
        //Sat Jan 23 21:16:52 CST 2021
    }
}
            
```

---

## Math 类

### 1.所属类包:  

​	`java.lang`

### 2.定义：

`Math` 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 其没有构造方法，看类的成员是否是静态的，如果是，通过类名就可以直接调用。

### 3.常用方法:

```java
public static int abs(int a)
//返回参数的绝对值
public static double ceil(double a)
//返回大于或等于参数的最小double值，等于一个整数
public static double floor(double a)
//返回小于或等于参数的最大double值，等于一个整数
public static int round(float a)
//按照四舍五入返回最接近参数的int
public static int max(int a,int b)
//返回两个int值中的较大值
public static int min(int a,int b)
//返回两个int值中的较小值
public static double pow(double a,double b)
//返回a的b次幂的值
public static double random()
//返回值为double的正值，该值[0.0,1.0)
public static double toDegrees(double angrad)
//弧度->角度
public static double toRadians(double angdeg)
//角度->弧度
```

---

## Random类

### 1.所属类包：

​	`java.util`

### 2.定义：

`Random`类中实现的随机算法是伪随机，也就是有规则的随机。在进行随机时，随机算法的起源数字称为种子数(`seed`)，在种子数的基础上进行一定的变换，从而产生需要的随机数字。

相同种子数的`Random`对象，相同次数生成的随机数字是完全相同的。也就是说，两个种子数相同的`Random`对象，第一次生成的随机数字完全相同，第二次生成的随机数字也完全相同。**如果想避免出现随机数字相同的情况，则需要注意，无论项目中需要生成多少个随机数字，都只使用一个`Random`对象即可。**

### 3.构造方法：

```java
public Random()
//该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。
public Random(long seed)
//该构造方法可以通过制定一个种子数进行创建。种子数只是随机算法的起源数字，和生成的随机数字的区间无关。
```

##### 案例：

```java
Random r1 = new Random(10);
Random r2 = new Random(10);
for(int i = 0;i < 2;i++){
System.out.println(r1.nextInt());
System.out.println(r2.nextInt());
}
//相同种子数的Random对象，相同次数生成的随机数字是完全相同的
```

### ·其他方法

```java
public boolean nextBoolean()
	//该方法的作用是生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。
public double nextDouble()
	//该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。
public int nextInt()
	//该方法的作用是生成一个随机的int值，该值介于int的区间，也就是-231到231-1之间。
public int nextInt(int n)
	//该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。
public void setSeed(long seed)
    //该方法的作用是重新设置Random对象中的种子数。设置完种子数以后的Random对象和相同种子数使用new关键字创建出的Random对象相同。
```

##### 案例：

```java
double d1 = r.nextDouble()*5;  	//生成[0,5.0)区间的小数
double d2 = r.nextDouble()*1.5+1; 	 //生成[1,2.5)区间的小数
int n3 = r.nextInt(10);  	 //生成[0,10)区间的整数
n3 = Math.abs(r.nextInt()%10); 	 //等价
int n4 = r.nextInt(18)-3;  	//生成[-3,15)区间的整数
n4 = Math.abs(r.nextInt()%18)-3;  	//等价
```

---

## Object类

### 1.所属类包：

`java.lang`

### 2.定义：

`Object`是所有类的父类，任何类都默认继承`Object`,回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法，因为它们的顶级父类只有无参构造方法

### 3.常用方法：

```java
public String toString()
//返回对象的字符串表示形式。建议所有子类重写该方法，自动生成
public boolean equals(Object obj)
//比较对象是否相等。默认比较地址，重写可以比较内容，自动生成
protected Object clone()
//创建并返回一个对象的拷贝
protected void finalize()
//当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。
int hashCode()
//获取对象的 hash 值
Class<?> getClass()
//获取对象的运行时对象的类
void wait()
//让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
void notify()
//唤醒在该对象上等待的某个线程
void notifyAll()
//唤醒在该对象上等待的所有线程
```

##### 案例:`protected Object clone()`

```java
        Person p = new Person(23, "zhang");
		Person p1 = p;
        //引用的复制,地址值是相同的，那么肯定是同一个对象
		System.out.println(p);
		System.out.println(p1);
//com.pansoft.zhangjg.testclone.Person@2f9ee1ac
//com.pansoft.zhangjg.testclone.Person@2f9ee1ac
```

![img](https://img-blog.csdn.net/20140116215846015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdqZ19ibG9n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

```java
		Person p = new Person(23, "zhang");
		Person p1 = (Person) p.clone();
		//两个对象的地址是不同的，也就是说创建了新的对象，而不是把原对象的地址赋给了一个新的引用变量
		System.out.println(p);
		System.out.println(p1);
//com.pansoft.zhangjg.testclone.Person@2f9ee1ac
//com.pansoft.zhangjg.testclone.Person@67f1fba0
```

![img](https://img-blog.csdn.net/20140116220717328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdqZ19ibG9n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### ·深拷贝or浅拷贝？

```java
public class Person implements Cloneable{
	
	private int age ;
	private String name;
	
	public Person(int age, String name) {
		this.age = age;
		this.name = name;
	}
	
	public Person() {}
 
	public int getAge() {
		return age;
	}
 
	public String getName() {
		return name;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return (Person)super.clone();
	}
}
		Person p = new Person(23, "zhang");
		Person p1 = (Person) p.clone();
		
		String result = p.getName() == p1.getName() 
				? "clone是浅拷贝的" : "clone是深拷贝的";
		
		System.out.println(result);
```



![img](https://img-blog.csdn.net/20140116224712140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdqZ19ibG9n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### 案例：`public boolean equals(Object obj)`

`equals` 方法在非空对象引用上实现相等关系：

- **自反性**：对于任何非空引用值 `x`，`x.equals(x)` 都应返回 `true`。
- **对称性**：对于任何非空引用值 `x` 和 `y`，当且仅当 `y.equals(x)` 返回 `true` 时，`x.equals(y)` 才应返回 `true`。
- **传递性**：对于任何非空引用值 `x`、`y` 和 `z`，如果 `x.equals(y)` 返回 `true`，并且 `y.equals(z)` 返回 `true`，那么 `x.equals(z)` 应返回 `true`。
- **一致性**：对于任何非空引用值 `x` 和 `y`，多次调用 `x.equals(y)` 始终返回 `true` 或始终返回 `false`，前提是对象上 `equals` 比较中所用的信息没有被修改。
- 对于任何非空引用值 `x`，`x.equals(null)` 都应返回 `false`。
- **严格区分String类的equals（）比较的是值大小，Object类比较的是引用类型的地址。**

```java
class Employee{
... //利用此例来表示equals()函数可以测试的方面
    public boolean equals(Object otherObj){
        if(this == otherObj) 
            return true;
    	//快速测试是否是同一个对象
        if(otherObj == null) 
            reutrn false;
    	//如果显式参数为null，必须返回false
        if(getClass() != otherObj.getClass()) 
            return false;
        //如果类不匹配，就不可能相等
        Employee other = (Employee)otherObj;
		//现在已经知道otherObj是个非空的Employee对象
        
        return name.equals(other.name)	//字符串
            && salary == other.salary	//float型
            && hireDay.equals(other.hireDay);	//字符串
    	//测试所有的字段是否相等
    }
}
```

##### 案例:`public String toString()`

```java
import java.util.*;
public class student {
	public static void main(String[] args) {
    	Vector<student_info> s=new Vector<student_info>(4);
   	 	Scanner sc = new Scanner(System.in);
    	student_info stu1=new student_info("李申兰",18,'女');
    	student_info stu2=new student_info("李胜利",19,'男');
    	student_info stu3=new student_info("张芳",18,'女');
    	student_info stu4=new student_info("李贺",20,'女');
   		s.addElement(stu1);
   		s.addElement(stu2);
   		s.addElement(stu3);
   		s.addElement(stu4);
    	for(int i=0;i<s.capacity();i++) 
    	{
        	System.out.println(s.elementAt(i));
    	}
    	sc.close();
		}
	}
class student_info
{
		String name;
		int age;
		char sex;
		student_info(String name,int age,char sex) 
		{
			this.name = name;
			this.age = age;
			this.sex = sex;
		}
		public String toString()
		{
            //需要重写该方法，否则显示的是getClass().getName() + '@' + Integer.toHexString(hashCode())
       	 	return "Student [姓名：" + name + ",年龄："+age+",性别："+sex+"]";
		}
}
//Student [姓名：李申兰,年龄：18,性别：女]
//Student [姓名：李胜利,年龄：19,性别：男]
//Student [姓名：张芳,年龄：18,性别：女]
//Student [姓名：李贺,年龄：20,性别：女]

```

##### 案例：`protected void finalize()`

- 当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列。

- 垃圾对象：没有有效引用指向此对象时，为垃圾对象。

- 垃圾回收：由GC销毁垃圾对象，释放数据存储空间。

- 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象。

- 手机回收机制：使用System.gc(); 通知JVM执行垃圾回收。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331202822496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dfbF94eg==,size_16,color_FFFFFF,t_70)

```java
public static void test(){
	String a = new String("haha");//1
	a = new String("java");//2
}
public static void main(String[] args){
	test();//3
}
//执行（1）时，a变量指向 haha ,haha处于可达状态；
//执行（2）时，再次创建java对象，a指向该对象，！！！此时，haha处于可恢复状态，java处于可达状态
```

##### 案例：`Class<?> getClass()`

- 该方法不可重写，要调用的话，一般和getName()联合使用，如getClass().getName();来返回现在使用的类的名字

##### 案例：`int hashCode()`

- 根据对象的地址或字符串或数字算出来的int数值，这个值跟地址值有关，但不是实际地址值。

##### 其余方法待讲到多线程时讲解

---

## BigDecimal类

### 1.所属类包：

`java.math`

### 2.定义：

### 3.构造方法：

```java
BigDecimal BigDecimal(double d); 
//不允许使用,因为它不能精确的得到相应的值，值会变大;
BigDecimal BigDecimal(String s); 
//常用,推荐使用
static BigDecimal valueOf(double d); 
//常用,推荐使用
```

### ·常用方法：

```java
public BigDecimal add(BigDecimal augend)：
    //加        
public BigDecimal subtract(BigDecimal subtrahend)：
    //减        
public BigDecimal multiply(BigDecimal multiplicand)：
    //乘        
public BigDecimal divide(BigDecimal divisor)：
    //除        
public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode)：
    //商，几位小数，舍取模式
toString()	
    //将BigDecimal对象的数值转换成字符串
doubleValue()	
    //将BigDecimal对象中的值以双精度数返回
floatValue()	
    //将BigDecimal对象中的值以单精度数返回
longValue()	
    //将BigDecimal对象中的值以长整数返回
intValue()	
    //将BigDecimal对象中的值以整数返回
setScale():
	//方法用于格式化小数点
```

##### 案例：`add(),subtract(),multiply(),divide()`

```java
import java.math.BigDecimal;

public class TestBigDecimal {
    public static void main(String[] args) {
        //加法
        double d1 = 1.234;
        double d2 = 2.341;
        System.out.println(d1 + d2);    //3.575

        System.out.println(d1 * d2);    //2.8887940000000003精度出问题了
        System.out.println(d1 / d2);    //0.5271251601879539 这个是对的

        //使用BigDecimal，加法
        BigDecimal b1 = new BigDecimal(Double.toString(d1));
        BigDecimal b2 = new BigDecimal(Double.toString(d2));
        System.out.println(b1.add(b2).doubleValue());       //3.575

        //减法
        System.out.println(b1.subtract(b2).doubleValue());  //-1.107

        //乘法
        System.out.println(b1.multiply(b2).doubleValue());  //2.888794

        //除法  保留小数点后两位,四舍五入
        System.out.println(b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP)); //0.53
    }
}
```

##### 案例：`setScale()`

主要介绍如何进行四舍五入

- setScale(1)表示保留一位小数，默认用四舍五入方式 

- setScale(1,BigDecimal.ROUND_DOWN)直接删除多余的小数位，如2.35会变成2.3 
- setScale(1,BigDecimal.ROUND_UP)进位处理，2.35变成2.4 
  -setScale(1,BigDecimal.ROUND_HALF_UP)四舍五入，2.35变成2.4

- setScaler(1,BigDecimal.ROUND_HALF_DOWN)四舍五入，2.35变成2.3，如果是5则向下舍

- setScaler(1,BigDecimal.ROUND_CEILING)接近正无穷大的舍入

- setScaler(1,BigDecimal.ROUND_FLOOR)接近负无穷大的舍入，数字>0和ROUND_UP作用一样，数字<0和ROUND_DOWN作用一样

setScaler(1,BigDecimal.ROUND_HALF_EVEN)向最接近的数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。

```java
public void test2() {  
    double num = 111231.5585;  
    BigDecimal b = new BigDecimal(num);  
    double result = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();  
    //四舍五入保留2位小数  
    System.out.println(result);  //111231.56  
}  
```

---

## BigInteger类

### 1.所属类包：

`java.math`

### 2.定义：

在Java中，由CPU原生提供的整型最大范围是64位`long`型整数。使用`long`型整数可以直接通过CPU指令进行计算，速度非常快。

如果我们使用的整数范围超过了`long`型怎么办？这个时候，就只能用软件来模拟一个大整数。`java.math.BigInteger`就是用来表示任意大小的整数，和`long`型整数运算比，`BigInteger`不会有范围限制，但缺点是速度比较慢。

### 3.构造方法：

```java
BigInteger(String val)
//将BigInteger的十进制字符串表示形式转换为BigInteger。
BigInteger(String val, int radix)
//将指定基数中BigInteger的String表示形式转换为BigInteger。(第一个参数是:一个数字字符串;第二个参数是:几进制)
```

#### ·常用方法

```java
基本运算：add()，subtract()，multiply()，divide()，mod()，remainder()，pow()，abs()，negate()；
//1.加 2.减 3.乘 4.除 需 b > 0，否则出现异常 6.求余 7.平方(需 n >= 0，否则出现异常) 8.取绝对值 9.取相反数
    
比较大小：
    compareTo()
    //返回一个int型数据：1 大于； 0 等于； -1 小于
	max()，min()：
    //分别返回大的（小的）那个BigInteger数据
    
static BigInteger valueOf(long val) 
  	//返回其值等于指定 long 的值的 BigInteger
boolean testBit(int n) 
    //当且仅当设置了指定的位时，返回 true，可用于菜单的权限控制
BigInteger setBit(int n) 
    //返回其值与设置了指定位的此 BigInteger 等效的 BigInteger，可用于菜单的权限控制
int bitLength()
    //返回此 BigInteger 的最小的二进制补码表示形式的位数，不包括符号位。
```

##### 案例：`add()，subtract()，multiply()，divide()，mod()，remainder()，pow()，abs()，negate()；`

```java
public void testBasic() {
		BigInteger a = new BigInteger("13");
		BigInteger b = new BigInteger("4");
		int n = 3;
		//1.加
		BigInteger bigNum1 = a.add(b);					//17
		//2.减
		BigInteger bigNum2 = a.subtract(b);				//9
		//3.乘
		BigInteger bigNum3 = a.multiply(b);				//52
		//4.除
		BigInteger bigNum4 = a.divide(b);				//3
		//5.取模(需 b > 0，否则出现异常：ArithmeticException("BigInteger: modulus not positive"))
		BigInteger bigNum5 = a.mod(b);					//1
		//6.求余
		BigInteger bigNum6 = a.remainder(b);			//1
		//7.平方(需 n >= 0，否则出现异常：ArithmeticException("Negative exponent"))
		BigInteger bigNum7 = a.pow(n);					//2197
		//8.取绝对值
		BigInteger bigNum8 = a.abs();					//13
		//9.取相反数
		BigInteger bigNum9 = a.negate();				//-13
	}
```

##### 案例：`compareTo(),max(),min()`

```java
public void testCompare() {
		BigInteger bigNum1 = new BigInteger("52");
		BigInteger bigNum2 = new BigInteger("27");

		//1.compareTo()：返回一个int型数据（1 大于； 0 等于； -1 小于）
		int num = bigNum1.compareTo(bigNum2);			//1

		//2.max()：直接返回大的那个数，类型为BigInteger
		//	原理：return (compareTo(val) > 0 ? this : val);
		BigInteger compareMax = bigNum1.max(bigNum2);	//52

		//3.min()：直接返回小的那个数，类型为BigInteger
		//	原理：return (compareTo(val) < 0 ? this : val);
		BigInteger compareMin = bigNum1.min(bigNum2);	//27
	}
```

#### ·常量

```java
        //0
		BigInteger zero = BigInteger.ZERO;
		//1
		BigInteger one = BigInteger.ONE;
		//10
		BigInteger ten = BigInteger.TEN;
```

##### 案例1：`setBit()、testBit()`

```java
import java.math.BigInteger;  
public class TestBigInteger {  
    public static void main(String[] args) {  
        BigInteger num = new BigInteger("0");  
        num = num.setBit(2);  
        num = num.setBit(1);  
        System.out.println(num);  
        System.out.println(num.testBit(2));  
        System.out.println(num.testBit(1));  
        System.out.println(num.testBit(3));  
    }  
}
//输出结果为
//6
//true
//true
//false

// 首先，实例化一个BigInteger对象，该对象初始化值为0，然后调用num.setBit(2)方法，这个方法的含义按照API解释，将先把num做一个二进制数据，然后将二进制中的第2位设置为1，最后返回该数据。我们知道0的二进制可以写成00000000，然后将第2位置加上1，也就变成了00000100（注意二进制是从第0位开始的），然后在调用num.setBit(1)，把第1位设置成1，num应该等于00000110，所以num对应的十进制值为6。
```

##### 案例2：`setBit()、testBit()`

模拟现实中菜单权限问题：

https://blog.csdn.net/sunon_/article/details/103253693

#### ·BigInteger的输入输出

```java
Scanner in = new Scanner(System.in); 
while(in.hasNext()) //等同于!=EOF
{
    BigInteger a;
    a = in.nextBigInteger();
    //直接读入 BigInteger
    
    /* String s = in.nextLine();
    BigInteger a = new BigInteger(s);
    //间接读入 BigInteger */
    
    System.out.print(a);
    //BigInteger 直接输出
    System.out.print(a.toString());
    //BigInteger 转化成十进制表示的 String
}
```

---

## Arrays类

### 1.所属类包：

​	`java.util `

### 2.定义：

​	主要包含了操纵数组的各种方法

### 3.常用方法(都是静态的)：

```java
binarySearch(Object[], Object key)
//二分查找方法
sort()
//数组升序排序方法
toString()
//返回数组的字符串形式
deepToString(Object[][] arrays)
//返回多维数组的字符串形式
fill(Object[] array,Object object)
//可以为数组元素填充相同的值
fill(Object[] array,int from,int to,Object object)
//对数组的部分元素填充一个值,从起始位置到结束位置，取头不取尾
```

##### 案例：`sort()`

```JAVA
import java.util.*;

public class Arr_Sort {
   public static void main(String args[]){
    int a[]={8,6,7,3,5,4};
    Arrays.sort(a);
    for(int i=a.length-1;i>=0;i--)  
         System.out.print(" " + a[i]);
    System.out.println();
  }
} 
//8 7 6 5 4 3
```

##### 案例：`binarySearch(Object[], Object key)`

- Object是目标数组，key是目标值，**要求目标数组必须要经过排序的**，否则无法找到正确的结果。
- 查询无非就是两种结果，一种是目标值在目标数组里，另一种是不在。
  - 所以返回值也分为正负两种，目标值在目标数组内的，返回下标（如果有多个相同的，无法确定找到的是哪个，因为是二分搜索）
  - 目标值不在数组内的，返回 -（第一个大于目标值的元素的下标+1），类似的，如果数组内的值都比目标值小，则是返回-（数组长度+1）

```JAVA
import java.util.Arrays;

public class Arr_BinarySearch {

  public static void main(String[] args) {
  int a[] = new int[] {1, 3, 4, 6, 8, 9}; 
  int x1 = Arrays.binarySearch(a, 5); 
  int x2 = Arrays.binarySearch(a, 4); 
  int x3 = Arrays.binarySearch(a, 0); 
  int x4 = Arrays.binarySearch(a, 10);
  System.out.println(x1+" "+x2+" "+x3+" "+x4);
  }      
}
//-4 2 -1 -7
```

##### 案例：`toString()`

```java
 	    int[] nums = {2,5,0,4,1,-10};
        System.out.println(Arrays.toString(nums));
        /*
         * 结果:[2, 5, 0, 4, 1, -10]
         */
```

##### 案例：`fill(Object[] array,Object object)`

```java
		int[] nums = {2,5,0,4,1,-10};
        Arrays.fill(nums, 1);
        for(int i :nums)
            System.out.print(i+" ");
        /* 之前:2 5 0 4 1 -10
         * 结果:1 1 1 1 1 1 
         */
```

##### 案例：`fill(Object[] array,int from,int to,Object object)`

```java
		int[] nums = {2,5,0,4,1,-10};
        //对数组元素下标2到4的元素赋值为3
        Arrays.fill(nums,2,5,3);
        for(int i :nums)
            System.out.print(i+" ");
        /* 之前:2 5 0 4 1 -10
         * 结果:2 5 3 3 3 -10 
         */
```

##### 案例：`deepToString(Object[][] arrays)`

```java
int[][] nums = {{1,2},{3,4}};
System.out.println(Arrays.deepToString(nums));
        /*
         * 结果:[[1, 2], [3, 4]]
         */
```

---

## Enum类

### 1.所属类包：

`java.lang`

### 2.定义：

类的对象是有限个、确定的时，我们称其为枚举类**注意Enum是抽象类**(布尔类型无法满足条件)，枚举类型的每一个枚举值（枚举属性）都是枚举类型的实例，且都是public static final类型的实例。

### 3.常见用法：

#### ·覆盖枚举的方法

下面给出一个toString()方法覆盖的例子。 

```java
public enum Color {  
    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
    // 成员变量  
    private String name;  
    private int index;  
    // 构造方法  
    private Color(String name, int index) {  
        this.name = name;  
        this.index = index;  
    }  
    //覆盖方法  
    @Override  
    public String toString() {  
        return this.index+"_"+this.name;  
    }  
}  
```

#### ·实现接口

```java
public interface Behaviour {  
    void print();  
    String getInfo();  
}  
public enum Color implements Behaviour{  
    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
    // 成员变量  
    private String name;  
    private int index;  
    // 构造方法  
    private Color(String name, int index) {  
        this.name = name;  
        this.index = index;  
    }  
//接口方法  
    @Override  
    public String getInfo() {  
        return this.name;  
    }  
    //接口方法  
    @Override  
    public void print() {  
        System.out.println(this.index+":"+this.name);  
    }  
}  
```

#### ·使用接口组织枚举

```java
public interface Food {  
    enum Coffee implements Food{  
        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  
    }  
    enum Dessert implements Food{  
        FRUIT, CAKE, GELATO  
    }  
}  
```

#### ·常用方法

```java
ordinal(): 
//返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。
compareTo(): 
//返回的是两个枚举值的所放置顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。
values()： 
//静态方法，返回一个包含全部枚举值的数组。
toString()： 
//返回枚举常量的名称。
valueOf()： 
//这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。
equals()： 
//比较两个枚举类对象的引用。
```

##### 案例：

```java
public class TestEnum {
    public enum ColorSelect {
        red, green, yellow, blue;    
    }
    /* 枚举也可以象一般的类一样添加方法和属性,你可以为它添加静态和非静态的属性或方法,这一切都像你在一般的类中做的那样. */
    public enum Season {
        winter, spring, summer, autumn;
        // 枚举列表必须写在最前面，否则编译出错
        private final static String location = "Phoenix";        

        public static Season getBest() {
            if (location.equals("Phoenix"))
                return winter;
            else
                return summer;
        }
    }
    /*还可以有构造方法*/
    public enum Temp {
        /*通过括号赋值,而且必须有带参构造器和一属性跟方法，否则编译出错
         * 赋值必须是都赋值或都不赋值，不能一部分赋值一部分不赋值
         * 如果不赋值则不能写构造器（方法），赋值编译也出错*/
        absoluteZero(-459), freezing(32),boiling(212), paperBurns(451);
        
        private final int value;
        public int getValue() {
            return value;
        }
        //构造器默认也只能是private, 从而保证构造函数只能在内部使用
        Temp(int value) {
            this.value = value;
        }
    }

    public static void main(String[] args) {
        /*
         * 枚举类型是一种类型，用于定义变量，以限制变量的赋值 赋值时通过"枚举名.值"来取得相关枚举中的值
         */
        ColorSelect m = ColorSelect.blue;
        switch (m) {
        /*注意:枚举重写了ToString(),所以枚举变量的值是不带前缀的
          *所以为blue而非ColorSelect.blue
          */

　　	   case red:
            System.out.println("color is red");
            break;
        case green:
            System.out.println("color is green");
            break;
        case yellow:
            System.out.println("color is yellow");
            break;
        case blue:
            System.out.println("color is blue");
            break;
        }
        System.out.println("遍历ColorSelect中的值");
       
        for(ColorSelect c:ColorSelect.values())/*通过values()获得枚举值的数组*/
            System.out.println(c); 

　　 	   System.out.println("枚举ColorSelect中的值有："+ColorSelect.values().length+"个");

 　　		/*ordinal()返回枚举值在枚举中的索引位置，从0开始*/
　　		System.out.println(ColorSelect.red.ordinal());//0
　　		System.out.println(ColorSelect.green.ordinal());//1
　　		System.out.println(ColorSelect.yellow.ordinal());//2
　　		System.out.println(ColorSelect.blue.ordinal());//3


　　		/*枚举默认实现了java.lang.Comparable接口*/ 
　　		System.out.println(ColorSelect.red.compareTo(ColorSelect.green));
         //0-1=-1

　　		System.out.println(Season.getBest());
        
         for(Temp t:Temp.values()){
            System.out.println(t+"的值是"+t.getValue());
             /*通过getValue()取得相关枚举的值*/
        }

    }
}
//color is blue
//遍历ColorSelect中的值
//red
//green
//yellow
//blue
//枚举ColorSelect中的值有：4个
//0
//1
//2
//3
//-1
//winter
//absoluteZero的值是-459
//freezing的值是32
//boiling的值是212
//paperBurns的值是451
```

---

## System类

### 1.所属类包：

`java.lang`

### 2.定义：

系统类，主要用于获取系统的属性数据，没有构造方法。

### 3.常用方法：

```java
static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
//复制数组：src：原数组,srcPos：原数组中的起始位置，也就是从原数组的哪一位开始拷贝,dest：目标数组,destPos：目标数据中的起始位置，也就是从目标数组的哪一个位置开始存储要拷贝的元素,length：要复制的数组元素的数量。
static long currentTimeMillis();
//该方法用于获取当前系统时间，返回的是毫秒值。返回当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。
static void exit(int status) 
//终止当前正在运行的 Java 虚拟机。
static void gc()  
//用来建议jvm赶快启动垃圾回收器回收垃圾。只是建议启动，但是Jvm是否启动又是另外一回事。
static Properties getProperties(); 
//该方法用于获取系统的所有属性。属性分为键和值两部分，它的返回值是Properties。
static String getProperty(key)；
//该方法用于根据系统的属性名获取对应的属性值。
```

##### 案例：`arraycopy()`

```java
public class Demo1 {
	public static void main(String[] args) {
		int[] srcArr = {10,12,14,16,19};
		//把srcArr的数组元素拷贝 到destArr数组中。
		int[] destArr = new int[4];
		System.arraycopy(srcArr, 2, destArr, 1, 2);
		System.out.println("目标数组的元素："+Arrays.toString(destArr));
	}
}
//目标数组的元素：[0,14,16,0]
```

##### 案例：`currentTimeMillis()`

```java
public class Demo2 {
	public static void main(String[] args) {
		System.out.println("当前的系统时间："+System.currentTimeMillis());
	}
}
//当前系统的时间：1520343986390
```

##### 案例：`gc()`

```java
class Person{
	String name;
	public Person(String name){
		this.name = name;
	}
	@Override
	public void finalize() throws Throwable{
		super.finalize();
		System.out.println(this.name+"被回收了……");
	}
}
public class Demo3 {
	public static void main(String[] args) {
		for(int i = 0;i<4;i++){
			new Person("张三"+i);
			System.gc();//建议马上启动垃圾回收器
		}
	}
}
//张三0被回收了......
//张三3被回收了......
//张三1被回收了......
//张三2被回收了......
```

##### 案例：`getProperty(key)`

![这里写图片描述](https://img-blog.csdn.net/20171017183910202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

```java
public class Demo6 {
	public static void main(String[] args) {
		String value = System.getProperty("os.name");
		System.out.println("当前系统是："+value);
	}
}
//当前系统是：Windows 10
```

---

# 正则表达式

### 1.基本语法：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200212144346768.png?)

https://blog.csdn.net/LJJZJ/article/details/94158329?utm_source=app&app_version=4.5.0

### 2.正则表达式常用大全：

https://blog.csdn.net/zpz2411232428/article/details/83549502?utm_source=app&app_version=4.5.0

### 3.相关类:

#### ·所属类包：

`java.util`

#### ·Pattern 类：

pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

#### ·Matcher 类：

Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

案例：

```java
/* import java.util.regex.*; */
public void RegexExample() {
	String input = "I am Jimmy from mp.csdn.net";
	String regex = ".*csdn.*";
		
	// 方式1：String 的 matches 方法
	boolean flag1 = input.matches(regex);
		
	// 方式2：Pattern 对象的 matches 方法
	boolean flag2 = Pattern.matches(regex, input);
		
	// 方式3： Matcher 对象的 matches 方法
	Pattern p = Pattern.compile(regex);
	Matcher m = p.matcher(input);
	boolean flag3 = m.matches();
	
	System.out.println("字符串中是否包含了'csdn'子字符串? " + flag1 );
	System.out.println("字符串中是否包含了'csdn'子字符串? " + flag2 );
	System.out.println("字符串中是否包含了'csdn'子字符串? " + flag3 );
}
输出结果：
	字符串中是否包含了'csdn'子字符串? true
	字符串中是否包含了'csdn'子字符串? true
	字符串中是否包含了'csdn'子字符串? true
```

##### ·实现功能

###### 1.字符串的匹配功能

```java
匹配功能 String的matches方法
 
    public static void main(String[] args) {
        // 匹配手机号码是否正确
        String phone = "15228119181";
        String regex = "1[345789]\\d{9}";
        boolean matches = phone.matches(regex);
    }
```

###### 2.字符串的切割功能

```java
切割功能 String的split(String regex)根据给定的正则拆分字符串
 
    public static void main(String[] args) {
        // 分割手机号的每一位数字
        String phone = "15228119181";
        String regex = "";
        String[] split = phone.split(regex);
        System.out.println(Arrays.toString(split));
    }
    结果： [1, 5, 2, 2, 8, 1, 1, 9, 1, 8, 1]
 
 
    public static void main(String[] args) {
        // 切割获取每一个单词（去除空格）
        String phone = "are      you  ok !";
        String regex = "\\p{Space}+";
        String[] split = phone.split(regex);
        System.out.println(Arrays.toString(split));
    }
    结果： [are, you, ok, !]
 
 
    这里有一个对split方法理解不正确的用法，要注意：
    public static void main(String[] args) {
        // 切割获取每一个单词（去除.）
        String phone = "are.you.ok !";
        //split方法传入的是正则，所以传入参数应该为 \\. 用来转义.符号
        String regex = ".";
        String[] split = phone.split(regex);
        //这样切割出来什么都没有
        System.out.println(Arrays.toString(split));
    }
    结果： []
```

###### 3.字符串的替换功能

```java
替换功能  String类的replaceAll(String regex,String replacement)
 
    将.替换成空格
    public static void main(String[] args) {
        String english = "are.you.ok !";
        String regex = "\\.";
        String s = english.replaceAll(regex, " ");
        System.out.println(s);
    }
    结果： are you ok !
 
    将中间的0替换成*
    public static void main(String[] args) {
        String phone = "15800001111";
        String s = phone.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
        System.out.println(s);
    }
    //结果： 158****1111
```

###### 4.字符串的获取功能

```java
获取功能 
 
    public static void main(String[] args) {
        // 获取3个字母组成的单词
        // 将正则封装成对象
        Pattern p = Pattern.compile("\\b[a-z]{3}\\b");
        // 指定要匹配的字符串
        Matcher m = p.matcher("da jia hao ming tian bu fang jia!");
        // 获取匹配的数据
        while (m.find()) {
            System.out.println(m.group());
        }
    }
```



