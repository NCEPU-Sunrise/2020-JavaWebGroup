# 集合
## 类集框架简介
从JDK1.2开始，Java中引入了类集开发框架，所谓的类集指的是一套动态对象数组的实现方案，在实际开发中，没有任何一项开发可以离开数组，但是传统的数组实现起来非常的繁琐，而且长度是其致命伤，正是因为长度问题，所以传统的数组是不可能大范围使用的，但是开发又离不开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构：链表、树。但是面对这些数据结构的实现，又不得不面对如下的一些问题：

* 数据结构的代码实现困难，对于一般的开发者是无法进行使用的；
* 对于链表或二叉树当进行更新处理的时候，维护是非常麻烦的；
* 对于链表或二叉树还需要尽可能保证其操作的性能；  

正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并提供了一系列的接口与实现子类，来帮助用户减少数据结构所带来的开发困难。但是最初的类集实现由Java本身的技术所限，所以对于数据的控制并不严格，全部采用了Object类型进行数据接收，而在JDK1.5后由于泛型将技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集的实现算法也得到了良好的性能提升。   
在整个类集框架中，提供了如下几个核心接口：Collection、List、Set、Map、Iterator、Enumeration、Queue、ListIterator。
## Collection集合接口
java.util.Collection是单值集合操作的最大的父接口，在该接口中定义有所有的单值数据的处理操作，这个接口中定义了如下的核心操作方法：    

* public boolean add​(E e) :向集合保存数据
* public boolean addAll​(Collection<? extends E> c):追加一组数据
* public void clear() :清空集合，让根节点为空，同时执行GC处理
* public boolean contains​(Object o):查询数据是否存在，需要equals()方法支持
* public boolean remove​(Object o):数据删除，需要equals()方法支持
* public int size():获取数据长度，最大值为Integer.MAX_VALUE
* public Object[] toArray():将集合变为对象数组返回
* public Iterator<E> iterator():将集合变为Iterator接口返回   

在进行集合操作时，有两个方法最为常用：【增加】add()、【输出】iterator()。

在JDK1.5版本之前，Collection只是一个独立的接口，但是从JDK1.5后，提供了Iterable父接口，并且在JDK1.8后针对于Iterable接口也得到了一些扩充。另外，在JDK1.2~JDK1.4的时代里面，如果要进行集合的使用往往会直接操作Collection接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口：允许重复的List子接口、不允许重复的Set子接口；     

![ALt Text](http://m.qpic.cn/psc?/V50n1dGd3Doigx0hCE5i1cHBhY4Ug0Hs/ruAMsa53pVQWN7FLK88i5t7x*NhK7D5FhjuNQocka2DsKhNjvNzK1gncpnuAF4cL.UZiRfp2Ia8EHuMkSWCdTVLTilhPRPWC*bervXOIqL4!/mnull&bo=ewMPAQAAAAADB1Q!&rf=photolist&t=5)    
## List接口（可重复）
List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下：  
`public interface List<E> extends Collection<E>`   
但是需要清楚的是List子接口对于Collection接口进行了方法扩充:   

* public E get​(int index):获取指定索引上的数据
* public E set​(int index, E element):修改指定索引数据
* public ListIterator<E> listIterator():返回ListIterator接口对象   

但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类：ArrayList（92%）、Vector（8%）、LinkedList（2%）。    
#### ArrayList子类
ArrayList是List子接口中使用最多的一个子类，但是这个子类在使用时也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在Java里面ArrayList类的定义如下：`public class ArrayList<E> extends AbstractList<E> mplements List<E>, RandomAccess, Cloneable, Serializable`,ArrayList封装的是一个数组。
范例：使用ArrayList实例化List父接口
```
import java.util.ArrayList;
import java.util.List;
public class Test {
    public static void main(String[] args) throws Exception {
        List<String> all = new ArrayList<String>();    //为List父接口进行实例化
        all.add("Hello");
        all.add("Hello");   //重复数据
        all.add("Wolrd");
        all.add("MLDN");
        System.out.println(all);    //[Hello, Hello, Wolrd, MLDN]
    }
}
```    
通过本程序可以发现List的存储特征：

* 保存的顺序就是其存储的顺序；
* List集合里面允许存在有重复数据；      

ArrayList构造：  

* public ArrayList()
* public ArrayList​(int initialCapacity)   

如果在实例化ArrayList类对象时没有传递初始化的长度，则默认情况下会使用空数组，当ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10 ，下次的增长就是20，如果在使用ArrayList子类的时候一定要估算出数据量有多少，如果超过了10个，那么采用有参构造的方法进行创建，以避免垃圾数组的空间产生。    
#### ArrayList保存自定义类对象   
范例：实现自定义类对象保存
```
package Tutorial;

import java.util.ArrayList;
import java.util.List;
public class Test {
    public static void main(String[] args) throws Exception {
        List<Person> all = new ArrayList<Person>();
        all.add(new Person("张三", 30));
        all.add(new Person("李四", 16));
        all.add(new Person("小强", 78));
        System.out.println(all.contains(new Person("小强", 78)));
        all.remove(new Person("小强", 78));
        all.forEach(System.out::println);    //方法引用代替了消费型的接口
        System.out.println(all);
    }
}
class Person {
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof Person)) {
            return false;
        }
        Person per = (Person) obj;
        return this.name.equals(per.name) && this.age == per.age;
    }
    // setter、getter、构造略
    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age;
    }
}
```   
#### LinkedList子类  
在List接口中还有一个比较常用的子类：LinkedList，这个类通过名称就可以发现其特点：基于链表的实现。那么首先观察一下LinkedList的定义：`public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable`     
范例：使用LinkedList实现集合操作
```
import java.util.LinkedList;
import java.util.List;
public class Test {
    public static void main(String[] args) throws Exception {
        List<String> all = new LinkedList<String>();
        all.add("Hello");
        all.add("Hello");
        all.add("Wolrd");
        all.add("MLDN");
        all.forEach(System.out::println);   //Hello Hello World MLDN
    }
}
```    
如果现在只是观察程序的功能会发现和ArrayList使用是完全一样的，但是其内部实现机制是完全不同的。    

* ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作；  
* 在使用List集合中的get()方法根据索引获取数据时，ArrayList的时间复杂度为“O(1)”、而LinkedList时间复杂度为“O(n)”（n为集合的长度）；  
* ArrayList在使用时默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降。LinkedList构造方法里面并没有提供像ArrayList那样的初始化大小的方法，而只是提供了无参构造处理：“public LinkedList()”，这时候可以使用LinkedList类保存。

#### Vector子类
Vector是一个原始古老的程序类，这个类是在JDK1.0时提供的。到了JDK1.2时由于许多开发者已经习惯于使用Vector，并且许多系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保留了下来，并让其多实现了一个List接口，观察Vector的定义结构(继承结构与ArrayList是相同的)：`public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable`    

Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的。Vector类中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。  

## Set接口(不可重复)
Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。

在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义为：`public interface Set<E> extends Collection<E>`   
需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()方法，也就是说无法实现指定索引数据的获取。 

从JDK1.9后，Set集合也提供了像List集合中类似的of()的静态方法。 
范例：验证Set集合特征
```
import  java.util.Set;
public class Test {
    public static void main(String[] args) throws Exception {
        //进行Set集合数据的保存，并设置有重复的内容
       Set<String> all=Set.of("Hello","World","MLDN","Hello","World");
       all.forEach(System.out::println);    //直接输出
       //Exception in thread "main" java.lang.IllegalArgumentException: duplicate element: Hello
    }
}
``` 
当使用of()这个新方法的时候，如果发现集合中存在重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。

Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用的子类：HashSet、TreeSet。

#### HashSet子类
HashSet是Set接口中使用最多的一个子类，HashSet子类的继承关系如下：`public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable`   
范例：观察HashSet类
```
import java.util.HashSet;
import  java.util.Set;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
       Set<String> all = new HashSet<String>();
       all.add("MLDN");
       all.add("NiHao");
       all.add("Hello");
       all.add("Hello");   //重复元素
       all.add("World");
       all.forEach(System.out::println);
    }
}
```
运行结果：
```
NiHao
Hello
World
MLDN
```
通过执行结果就可以发现HashSet的操作特点：不允许保存重复元素（Set接口定义的），另外一个特点就是HashSet中保存的数据是无序的。  
#### TreeSet子类
Set接口的另外一个子接口就是TreeSet，与HashSet最大区别在于TreeSet集合里面保存的数据是有序的，首先来观察TreeSet类的定义：public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable    

范例：使用TreeSet子类
```
import java.util.TreeSet;
import  java.util.Set;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
       Set<String> all = new TreeSet<String>();
       all.add("MLDN");
       all.add("NiHao");
       all.add("Hello");
       all.add("Hello");   //重复元素
       all.add("World");
       all.forEach(System.out::println);
    }
}
```
运行结果：
```
Hello
MLDN
NiHao
World
```
当利用TreeSet保存数据的时候，所有的数据将按照数据的升序进行自动排序处理。是这个类必须要实现Comparable接口，只有实现了此接口才能够确认出对象的大小关系。。TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap（树）就需要根据Comparable来确定对象的大小关系。    

范例：使用自定义的类实现排序的处理操作  
```
import java.util.Set;
import java.util.TreeSet;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Set<Person> all=new TreeSet<Person>();
        all.add(new Person("张三",19));
        all.add(new Person("李四",19));   //年龄相同，但姓名不同
        all.add(new Person("王五",20));   //数据重复
        all.add(new Person("王五",20));   //数据重复
        all.add(new Person("小强",78));
        all.forEach(System.out::println);
    }
}

class Person implements Comparable<Person>{    //比较器
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age;
    }
    @Override
    public int compareTo(Person per) {
        if(this.age < per.age){
            return -1 ;
        }else if(this.age > per.age) {
        return 1;
        }else {
            return this.name.compareTo(per.name);
        }
    }
}
```  
运行结果：
```
姓名：张三、年龄：19
姓名：李四、年龄：19
姓名：王五、年龄：20
姓名：小强、年龄：78
```  
在使用自定义类对象进行比较处理的时候，一定要将该类中所有属性都依次进行大小关系的匹配，否则某一个或者几个属性相同的时候也会被认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。

由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发中应该首选HashSet子类进行存储。    
##### 重复元素消除
TreeSet类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的：

* 对象编码：public int hashCode();
* 对象比较：public boolean equals​(Object obj); 

在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果该编码不存在，则表示数据不存在，证明没有重复，如果该编码存在，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建HashCode()与equals()方法。  
范例：
```   
import java.util.Set;
import java.util.HashSet;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Set<Person> all=new TreeSet<Person>();
        all.add(new Person("张三",19));
        all.add(new Person("李四",19));   //年龄相同，但姓名不同
        all.add(new Person("王五",20));   //数据重复
        all.add(new Person("王五",20));   //数据重复
        all.add(new Person("小强",78));
        all.forEach(System.out::println);
    }
}

class Person implements Comparable<Person>{    //比较器
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result +age;
        result = prime * result + ((name == null)? 0 : name.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Person other = (Person) obj;
        if (age != other.age)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        }else if (!name.equals(other.name))
            return false;
        return true;
    }

    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age;
    }
    @Override
    public int compareTo(Person per) {
        if(this.age < per.age){
            return -1 ;
        }else if(this.age > per.age) {
        return 1;
        }else {
            return this.name.compareTo(per.name);
        }
    }
}
```   
运行结果：
```
姓名：小强、年龄：78
姓名：李四、年龄：19
姓名：王五、年龄：20
姓名：张三、年龄：19
```  

在Java程序中，真正的重复元素的判断处理利用的就是hashCode和equals()两个方法共同作用完成的，而只有在排序要求的情况下（TreeSet）才会利用Comparable接口来实现。

## 集合输出 
集合输出实际上从JDK1.8开始就在Iterable接口中提供了一个forEach()方法，但是这种方法输出并不是传统意义上集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式：Iterator迭代输出（95%）、ListIterator双向迭代输出（0.1%）、Enumeration枚举输出（4.9%）、foreach输出（与Iterator相当）。    
#### Iterator迭代输出  
通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个iterator()操作方法，通过此方法可以获取Iterator接口对象（在JDK1.5之前，这一方法直接定义在Collection接口之中）。    

获取Iterator接口对象：`public Iterator<T> iterator​();`    

在Iterator接口里面定义有如下的方法：   

|方法名称|描述|
|----|----|
|public boolean hasNext​()|判断是否有数据|
|public E next​()|取出当前数据|
|default void remove​()|删除|
  
范例：使用Iterator输出
```
import java.util.Set;
import java.util.Iterator;
public class Test {
    public static void main(String[] args) throws Exception {
        Set<String> all = Set.of("Hello", "World", "MLDN");
        Iterator<String> iter = all.iterator();   //实例化Iterator接口对象
        while (iter.hasNext()) {
            String str = iter.next();
            System.out.println(str);   // World Hello MLDN
        }
    }
}
```

但是对于Iterator接口中的remove()方法的使用需要特别注意一下（如果不是必须不要使用）。实际上在Collection接口中定义有数据的删除操作方法，但是在进行迭代输出的过程中如果你使用了Collection中的remove()方法会导致迭代失败。   
范例：采用Collection集合中remove()方法删除
```
import java.util.Set;
import java.util.Iterator;
import java.util.HashSet;
public class Test {
    public static void main(String[] args) throws Exception {
        Set<String> all = new HashSet<String>();
        all.add("Hello");
        all.add("World");
        all.add("MLDN");
        Iterator<String> iter = all.iterator();   //实例化Iterator接口对象
        while (iter.hasNext()) {
            String str = iter.next();
            if ("World".equals(str)) {
                all.remove("World");  //Collection集合方法
            }else {
                System.out.println(str);   //  Hello   Exception in thread "main" java.util.ConcurrentModificationException
            }
        }
    }
}
```  

此时无法进行数据删除处理操作，那么就只能够利用Iterator接口中的remove()方法删除。  
范例：使用Iterator接口删除方法
```
import java.util.Set;
import java.util.Iterator;
import java.util.HashSet;
public class Test {
    public static void main(String[] args) throws Exception {
        Set<String> all = new HashSet<String>();
        all.add("Hello");
        all.add("World");
        all.add("MLDN");
        Iterator<String> iter = all.iterator();   //实例化Iterator接口对象
        while (iter.hasNext()) {
            String str = iter.next();
            if ("World".equals(str)) {
                iter.remove();  //Collection集合方法
            }else {
                System.out.println(str);   //  Hello   Exception in thread "main" java.util.ConcurrentModificationException
            }
        }
        System.out.println("*** "+ all);  
    }
}
```
运行结果：
```
Hello
MLDN
*** [Hello, MLDN]
```  
#### ListIterator双向迭代输出
使用Iterator进行的迭代输出操作有一个特点：只允许由前向后输出，而如果现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口：ListIterator接口来实现了。需要注意的是，如果想要获取ListIterator接口对象，Collection中并没有定义相关的处理方法，但是List子接口有，也就是说这个输出的接口是专门为List集合准备的。 

ListIterator接口中定义有如下的操作方法：

* 判断是否有前一个元素：public boolean hasPrevious()
* 获取当前元素：public E previous()  

范例：实现双向迭代
```
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
public class Test {
    public static void main(String[] args) throws Exception {
        List<String> all = new ArrayList<String>();
        all.add("Hello");
        all.add("World");
        all.add("MLDN");
        ListIterator<String> iter = all.listIterator();
        System.out.print("由前向后输出：");
        while (iter.hasNext()) {
            System.out.print(iter.next() + "、");
        }
        System.out.print("\n由后向前输出：");   //由前向后输出：Hello、World、MLDN、
        while (iter.hasPrevious()) {
            System.out.print(iter.previous() + "、");  //由后向前输出：MLDN、World、Hello、
        }      
    }
}
```
如果想实现由后向前的遍历，那么首先要实现的是由前向后实现遍历处理。  

#### Enumeration输出
Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，所以要想获取Enumeration接口对象，那么必须依靠Vector类提供的方法：   
获取Enumeration：`public Enumeration<E> elements()`    

在Enumeration接口中定义有两个操作方法：

* 判断是否有下一个元素：public boolean hasMoreElements()
* 获取当前元素：public E nextElement()   

范例：使用Enumeration实现输出
```
import java.util.Enumeration;
import java.util.Vector;
public class Test {
    public static void main(String[] args) throws Exception {
        Vector<String> all = new Vector<String>();
        all.add("Hello");
        all.add("World");
        all.add("MLDN");
        Enumeration<String> enu = all.elements();
        while (enu.hasMoreElements()) {
            String str = enu.nextElement();
            System.out.print(str +"、");    //Hello、World、MLDN、
        }
    }
}
```
由于该接口出现的时间较长了，所以在一些比较早的开发过程中，也有部分的方法只支持Enumeration输出操作，但随着类方法的不断完善，大部分的操作都能直接利用Iterator实现了。   

#### foreach输出  
除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。   
范例：使用foreach输出  
```
import java.util.ArrayList;
import java.util.List;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        List<String> all = new ArrayList<String>();
        all.add("Hello");
        all.add("World");
        all.add("MLDN");
        for (String str : all){
            System.out.print(str+"、");   //Hello、World、MLDN、
        }     
    }
}
```
这种输出最初出现时很多人并不建议使用，因为标准的集合操作还是以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多语法也开始被大部分人所习惯。
## Map接口
之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，而在数据结构中除了可以进行单个对象的保存外，也可以进行二元偶对象的保存（key=value）的形式来存储，而存储二元偶对象的核心意义在于需要通过key获取对应的value。

在开发中，Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。

Map接口是进行二元偶对象保存的最大父接口。该接口定义如下：
`public interface Map<K,V>`   
该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是在整体操作的时候需要保存两个内容，在Map接口中定义有许多操作方法，但是需要记住以下的核心操作方法：   
|方法名称|描述|
|----|----|
|public V put​(K key,V value)|向集合中保存数据|
|public V get​(Object key)|根据key查询数据|
|public Set<Map.Entry<K,V>> entrySet()|将Map集合转为Set集合|
|public boolean containsKey​(Object key)|查询指定的key是否存在|
|public Set<K> keySet()|将Map集合中的key转为Set集合|
|public V remove​(Object key)|根据key删除指定的数据|
从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用。

范例：观察Map集合的特点
```
import java.util.Map;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
//        Map<String,Integer> map=Map.of("one",1,"two",2);
//        System.out.println(map);     //{one=1,two=2}
//       
//        Map<String,Integer> map=Map.of("one",1,"two",2,"one",101);
//        System.out.println(map);    //Exception in thread "main" java.lang.IllegalArgumentException: duplicate key: one
        
        Map<String,Integer> map=Map.of("one",1,"two",2,null,0);
        System.out.println(map);  //Exception in thread "main" java.lang.NullPointerException
    }
}
```  
在Map集合之中数据的保存就是按照“key=value”的形式存储的，并且使用of()方法操作时里面的数据是不允许重复，如果重复则会出现“IllegalArgumentException”异常，如果设置的内容为null，则会出现“NullPointerException”异常。

对于现在见到的of()方法严格意义上来说并不是Map集合的标准用法，因为正常的开发中需要通过Map集合的子类来进行接口对象的实例化，而常用的子类：HashMap、HashTable、TreeMap、LinkedHashMap。  
####
HashMap子类
HashMap是Map接口中最为常见的一个子类,该类的主要特点是无序存储，通过Java文档首先来观察一下HashMap子类的定义：  
`public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable`   
该类的定义继承形式符合之前的集合定义形式，依然提供有抽象类并且依然需要重复实现Map接口。  

范例：观察Map集合的使用
```
import java.util.HashMap;
import java.util.Map;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Map<String,Integer> map = new HashMap<String,Integer>();
        map.put("one",1);
        map.put("two",2);
        map.put("one",101);    //key重复
        map.put(null,0);       //key为null
        map.put("zero",null);    //value为null
        System.out.println(map.get("one"));    //key存在：101
        System.out.println(map.get(null));    //key存在：0
        System.out.println(map.get("ten"));     //key不存在：null
    }
}
```  
以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或者value保存null的数据，同时也可以发现即便保存数据的key重复，那么也不会出现错误，而是出现内容的替换。

但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回旧的value。   

范例：观察put()方法
```
Map<String, Integer> map = new HashMap<String,Integer>();
        System.out.println(map.put("one", 1));    //key不重复，返回null：null
        System.out.println(map.put("one", 101));   //key重复，返回旧数据：1
```   
在设置了相同key的内容的时候，put()方法会返回原始的数据内容。   

在进行HashMap的put()操作时，如何实现容量扩充？

* 在HashMap类中提供了一个“DEFAULT_INITIAL_CAPACITY”的常量，作为初始化的容量配置，而这个常量的默认大小为16个元素，也就是说默认的可以保存的最大内容是16；
* 当保存的内容的容量超过了一个阈值（DEFAULT_LOAD_FACTOR=0.75f），相当于“容量*阈值=12”保存12个元素的时候就会进行容量的扩充；
* 在进行扩充的时候HashMap采用的是成倍的扩充模式，即：每一次都扩充2倍的容量。

#### LinkedHashMap子类
HashMap虽然是Map集合中最为常用的子类，但是其本身保存的数据都是无序的（有序与否对Map没有影响），如果现在希望Map集合中的保存的数据的顺序为其增加顺序，则就可以更换子类为LinkedHashMap（基于链表实现的），观察LinkedHashMap类的定义形式：   
`public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>`     
既然是链表保存，所以一般在使用LinkedHashMap类时数据量不要特别大，因为会造成时间复杂度攀升。

范例：使用LinkedHashMap   
```
import java.util.LinkedHashMap;
import java.util.Map;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Map<String, Integer> map = new LinkedHashMap<String, Integer>();
        map.put("one", 1);
        map.put("two", 2);
        map.put("one", 101);
        map.put("null", 0);
        map.put("zero", null);
        System.out.println(map);    //{one=101, two=2, null=0, zero=null}
    }
}
```  
通过此时的程序执行可以发现当使用LinkedHashMap进行存储之后所有数据的保存顺序为添加顺序。

#### HashTable子类
HashTable类是从JDK1.0时提供的，与Vector、Enumeration属于最早的一批动态数组的实现类，后来为了将其继续保留下来，所以让其多实现了一个Map接口，HashTable类的定义如下：
`public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, Serializable`

范例：观察HashTable子类的使用
```
import java.util.Hashtable;
import java.util.Map;
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Map<String, Integer> map = new Hashtable<String,Integer>();
        map.put("one", 1);
        map.put("two", 2);
        map.put("one", 101);
        // map.put(null, 0);     //不能为空
        // map.put("zero",null);   //不能为空，Exception in thread "main" java.lang.NullPointerException
        System.out.println(map);  // {two=2, one=101}
    }
}
```
通过观察可以发现在HashTable中进行数据存储时设置的key或value都不允许为null，否则会出现NullPointerException异常。   

HashMap与HashTable的区别:

* HashMap中的方法都属于异步操作，非线程安全，HashMap允许保存有null的数据；  
* HashTable都属于同步方法（线程安全），HashTable不允许保存null，否则会出现NullPointerException异常；

