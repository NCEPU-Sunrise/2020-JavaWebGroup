# 注解（Annotation） 
## Annotation简介 
Annotation是从JDK1.5开始提出的一个新的开发技术结构。利用Annotation可以有效减少程序配置的代码，并且可以利用Annotation进行一些结构化的定义。
Annotation是以一种注解的形式实现的程序开发。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。目前Annotation技术得到了非常广泛的应用，并且已经在所有的项目开发中都会存在。    
如果要清楚Annotation的产生意义，则必须了解一下程序开发结构的历史，从历史    
过程一：在程序定义的时候将所有可能使用到的资源全部定义在程序代码之中。

* 如果此时服务器的相关地址发生了改变，那么对于程序而言就需要进行源代码的修改，卫华需要由开发人员来完成，明显是不方便的。   

过程二：引入配置文件，在配置文件中定义全部要使用的服务器资源    

* 在配置项不多的情况下，此类配置非常好用，并且是否简单，但是所有的项目都采用这种方式开发，那么就可能产生一种可怕的场景：配置文件暴多;  
* 所有的操作都需要通过配置文件完成，这样对于开发的难度提升了   

过程三：将配置信息重新写回到程序里，利用一些特殊的标记与程序代码进行分离，这就是注解的作用，也就是Annotation退出的基本依据。   

* 如果全部都使用注解开发，难度太高了，配置文件有好处，也有缺点，所以目前的开发基本是配置文件加上注解的形式完成的。注意，注解与注释是有一定区别的，注解的内容可以在编译，类加载，运行时被读取，并执行相应的处理。   

Java的注解可以分为三类：

* 第一类是由编译器使用的注解，例如：

    - @Override：让编译器检查该方法是否正确地实现了覆写；
    - @SuppressWarnings：告诉编译器忽略此处代码产生的警告。    
这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。

* 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。

* 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。

定义一个注解时，还可以定义配置参数。配置参数可以包括：

* 所有基本类型；
* String；
* 枚举类型；
* 基本类型、String、Class以及枚举的数组。
因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。

注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。
此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。如果只写注解，相当于全部使用默认值。

本次我们只讲解Java中提供的几个基本注解：@Override、@Deprecated、@SuppresWarnings。
## 准确覆写：@Override
当子类继承某一个父类之后如果发现父类中的某些方法功能不足的时候往往会采用覆写的形式来对方法功能进行扩充。下面我们首先来观察一种覆写操作。    
###### 范例：
```
package Tutorial;

class Channel {
    public void connect() {
        System. out.println ( "**********Channel*******");
    }
}
class DatabaseChannel extends Channel {
    public void connect() {
        System.out.println("子类定义的通道连接探作。") ;
    }
}
public class Test {
    public static void main (String args[]) {
        new DatabaseChannel().connect () ;
    }
}

```
开发之中经常出现的两个问题:   

* 虽然要明确的继承一个父类并且进行方法的覆写，但是有可能由于疏忽忘记编写extends,就不是覆写了   
* 在进行方法覆写是单词写错了  

为了避免这种问题的出现，可以在明确覆写的方法上追加有一个注解。    
```
class DatabaseChannel extends Channel {
    @Override
    public void connect() {
        System.out.println("子类定义的通道连接探作。") ;
    }
}
```
该注解只要是帮助开发者在程序编译的时候可以检查出程序的错误。
## 过期声明：@Deprecated
所谓的过期操作指的是在一个软件项目的迭代开发过程之中，可能有某一个方法或者是某个类由于在最初设计的时候考虑不周（存在缺陷），导致新版本的应用会有不适应的地方（老版本不影响），这个时候鱼不能直接删除这些操作，那么就希望给一个过渡的时间，于是采用过期声明，目的是告诉新用户这些操作不要再用了，老的用户用就用了。    
因此@Deprecated的作用是标记过时方法。如果使用该方法，会报编译警告（API过时）。
###### 范例
```
class Channel {
    @Deprecated
    public void connect() {//没有返回值，后面想要弃用
        System. out.println ( "**********Channel*******");  
    }
    
    public String connection() {
        return "获取了通道连接信息";
    }
}
public class Test {
    public static void main (String args[]) {
        new Channel().connect () ;
    }
}
```
## 压制警告：@SuppressWarnings
举例：有一辆车很智能，看到前面有人它就报警。车现在走在一个人很多的大街上，它一直在报警，但其实刺激已经知道了，并且在很谨慎地开，但警报却还是一直在响，这时候这个警报就很多余，所以我们是否可以想一个办法关闭这个警报。     
以之前的过期程序为例，可以发现在进行程序编译的时候会出现一个错误的提示信息：`JavaDemo.java使用或覆盖了已过时的API.有关详细信息,请使用-Xlint:deprecation重新编译。`   
如果此时不愿意见到这些提示信息（或者已经明确的知道了错误在那里),那么就可以进行警告信息的压制。  
```
public class Test {
    @SuppressWarnings(value = {"deprecation"})
    public static void main (String args[]) {
        new Channel().connect () ;
    }
}
```
## 反射与注解
## 获取Annotation信息
在进行类或者方法的定义的时候都可以使用一系列的Annotion进行声明，于是如果想要获取这些Annotation的信息，可以直接通过反射来完成。在java.lang.reflect里面有一个AccessibleObject类，在这个类中提供有获取Annotation类的方法。   
![Alt text](http://m.qpic.cn/psc?/V50n1dGd3Doigx0hCE5i1cHBhY4Ug0Hs/ruAMsa53pVQWN7FLK88i5uewrUJro2G57uTe0oUQbqdKPRLCCj.zQNL2S9jraj7Z1ZKzaJqu58PSLu.tA0fGTJPHp*lBBgIEkj2YhLzW0Oo!/mnull&bo=YANiAQAAAAADByI!&rf=photolist&t=5)    

* 获取全部Annotation：
public Annotation[] getAnnotations()
* 获取指定Annotation：
public <T extends Annotation> T getAnnotation​(Class<T> annotationClass)     
范例：定义一个接口，并在接口在使用Annotation
```
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        {   //获取接口上的Annotation信息
            Annotation annotations [] = IMessage.class.getAnnotations();  //获取接口上的全部Annotation
            for (Annotation temp : annotations) {
                System.out.println(temp);
                //@java.lang.FunctionalInterface()
                //@java.lang.Deprecated(forRemoval=false, since="1.0")
            }
        }
        System.out.println("-----------------------");
        {//获取MessageImpl子类上的Annotation信息
            Annotation annotations []= MessageImpl.class.getAnnotations();  //获取类上的全部Annotation
            for (Annotation temp : annotations) {
                System.out.println(temp);
            }
        }
        System.out.println("-----------------------");
        {   //获取MessageImpl.toString()方法上的Annotation信息
            Method method = MessageImpl.class.getDeclaredMethod("send", String.class);
            Annotation annotations [] = method.getAnnotations();  
            for (Annotation temp : annotations) {
                System.out.println(temp);
            }
        }
    }
}
@FunctionalInterface    //程序执行时可以获取
@Deprecated(since = "1.0")     
interface IMessage {     //有2个Annotation
    public void send(String msg);
}
@SuppressWarnings("serial")     //无法在程序执行时获取
class MessageImpl implements IMessage, Serializable {
    @Override      //无法在程序执行时获取
    public void send(String msg) {
        System.out.println("【消息发送】" + msg);
    }
}


```
不同的Annotation有它的存在范围，下面对比两个Annotation：
@FunctionalInterface（运行时）：
```
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}
```
@SuppressWarnings（源代码）：
```
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {}
```   
现在发现“@FunctionalInterface”是在运行时生效的Annotation，所以程序执行时可以获取Annotation；而“@SuppressWarnings”是在源代码编写时有效。
在RetentionPolicy枚举类中还有一个class的定义，指的是在类定义时生效。
#### 自定义Annotation
现在已经清楚了Annotation的获取，以及Annotation的运行策略，但是最为关键性的因素是如何实现自定义的Annotation呢？为此在Java中提供了新的语法，使用“@interface”来定义Annotation。   
范例：自定义Annotation  
```
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)   //定义Annotation的运行策略
@interface DefaultAnnotation {      //自定义的Annotation
    public String title();      //获取数据
    public String url() default "www.mldn.cn";   //获取数据
class Message {
    @DefaultAnnotation(title = "MLDN")
    public void send(String msg) {
        System.out.println("【消息发送】" + msg);
    }
}
public class JavaAPIDemo {
    public static void main(String[] args) throws Exception {
        Method method = Message.class.getMethod("send",String.class);  //获取指定方法
        DefaultAnnotation  anno = method.getAnnotation(DefaultAnnotation.class);  //获取指定的Annotation
        //System.out.println(anno.title());  //直接调用Annotation中的方法  MLDN
        //System.out.println(anno.url());    //直接调用Annotation中的方法  www.mldn.cn
        //直接调用Annotation中的方法
        String msg = anno.title()+"（"+anno.url()+")";  //消息内容 
        method.invoke(Message.class.getDeclaredConstructor().newInstance(), msg);   //【消息发送】MLDN（www.mldn.cn)
    }
}
```  
使用Annotation之后的最大特点是可以结合反射机制实现程序的处理。    
#### 整合工厂设计模式与Annotation
现在已经清楚了Annotation的整体作用，但是Annotation到底在开发中能做哪些事情呢？为了进一步理解Annotation的处理目的，下面将结合工厂设计模式来应用Annotation操作。  
```
package Tutorial;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Test {
    public static void main(String[] args) throws Exception {
        //IMessage msg = Factory.getInstance(MessageImpl.class);
        //msg.send("www.mldn.cn")
        MessageService messageService=new MessageService();
        messageService.send("www.mldn.cn");
    }
}
@Retention(RetentionPolicy.RUNTIME)
@interface UserMessage{
    public Class <?> clazz();
}
@UserMessage(clazz =MessageImpl.class )  //利用Annotation实现了类的使用
class MessageService{
    private IMessage message;
    public MessageService(){
        UserMessage use=MessageService.class.getAnnotation(UserMessage.class);
        this.message = (IMessage)Factory.getInstance(use.clazz());  //直接通过Annotation获取
    }
    public void send(String msg){
        this.message.send(msg);
    }
}
class Factory  {
    private Factory() {}
    public static <T> T getInstance(Class<T> clazz){   //直接返回一个实例化对象
        try {
            return (T)new MessageProxy().bind(clazz.getDeclaredConstructor().newInstance());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
interface IMessage {
    public void send(String msg);
}
class MessageImpl implements IMessage {
    @Override
    public void send(String msg) {
        System.out.println("【消息发送】"+msg);
    }
}
class NetMessageImpl implements IMessage {
    @Override
    public void send(String msg) {
        System.out.println("【网络消息发送】"+msg);
    }
}
class MessageProxy implements InvocationHandler {
    private Object target;
    public Object bind(Object target){
        this.target = target;
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
    public  boolean connect(){
        System.out.println("【代理操作】进行消息发送通道的连接。");
        return true;
    }
    public void close() {
        System.out.println("【代理操作】关闭连接通道。");
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if(this.connect()){
                return method.invoke(this.target, args);
            }else {
                throw new Exception("【ERROR】消息无法进行发送！");
            }      
        }finally {
            this.close();
        }
    }
}
```
程序结果：
```
【代理操作】进行消息发送通道的连接。
【消息发送】www.mldn. cn
【代理操作】关闭连接通道。

```  
更换`@UserMessage(clazz =NetMessageImpl.class)`   
由于Annotation的存在，所以面向接口的编程处理将可以直接利用Annotation的属性完成控制，从而使得整体代码变得整洁。