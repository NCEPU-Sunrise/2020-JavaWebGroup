知识点:  

1.异常的产生以及对于程序的影响;

2.异常处理的格式;

3.异常的处理流程;

4.Throw,throws关键字的使用;

5.异常处理的使用标准;

6.自定义异常.



## 异常的描述
其实异常可以看做在我们编程过程中遇到的一些意外情况，当出现这些意外情况时我们无法继续进程正常的逻辑处理，此时我们就可以抛出一个异常。

异常分为3种：

* Error - 描述了Java运行系统中的内部错误以及资源耗尽的情况。应用程序不应该抛出这种类型的对象。如果这种内部错误出现，除了通知用户错误发生以及尽力安全的退出程序外，在其他方面是无能为力的。

* 编译时异常 Exception - 它指出了合理的应用程序想要捕获的条件。Exception又分为两类：IOException和RuntimeException。由编程导致的错误，会导致RuntimeException异常。而其他错误原因导致的异常（例如因为I/O错误导致曾经运行正确的程序出错），都不会导致RuntimeException异常。

* 运行时 RuntimeException - 表示运行时异常，不强制要求写出显示的捕获代码，但如果没有被捕获到，则线程会被强制中断  




引入异常之后的好处：

* 把错误代码从正常代码中分离出来进行单独处理，这样使代码变得更加整洁；
* 当出现一些特殊情况时，我们还可以抛出一个检查异常，告知调用者让其处理。
* 异常处理可以使程序即使出现了异常,也可以让程序正常的执行完毕

## 处理异常
在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。

### 捕获异常

**捕获异常**：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

捕捉异常通过 try-catch 语句或者 try-catch-finally 语句实现。

```
try{
    //有异常的代码
}catch(异常类型 对象){
    //异常处理
}catch(异常类型 对象){
    //异常处理
}finally{
    //不管是否出现异常,都执行的统一代码
}
```

对于以上的操作组合:try...catch,try...catch...finally,try...finally(不建议使用)

使用异常处理,即使程序中出现了异常,也可以正常执行

出现异常的目的是解决异常,所以为了能够进行异常的处理,可以使用异常类中提供的printStackTrace()方法进行异常信息的输出.

###### try···catch···finally 异常处理范例:
```
public class Test{

    public static void main(String[] args) {

        System.out.println("算术运算开始");

        try{
            System.out.println(10/0);
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            System.out.println("不管是否有异常我都会执行");
        }

        System.out.println("算术运算结束");
    }

}
```

### 抛出异常

**抛出异常**：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。

任何 Java 代码都可以抛出异常，如：自己编写的代码、来自 Java 开发环境包中代码，或者 Java 运行时系统。无论是谁，都可以通过 Java 的 throw 语句抛出异常。

从方法中抛出的任何异常都必须使用 throws 子句。
#### throws关键字

throws关键字主要用于方法声明上,指的是当方法之中出现异常后交由被调用处处理

也就说调用了具有throws声明的方法之后,不管操作是否出现异常,都必须使用try...catch来进行异常处理

在主方法上如果继续抛出异常,那么这个异常就交给JVM进行处理,也就是采用默认的处理方式,输出异常信息,而后结束程序调用

主方法上不要加上throws,因为程序如果出错了,也希望能够正常执行.

#### throw关键字

在程序中可以使用throw手动抛出异常
```
Scanner sc = new Scanner(System.in);
try{
    int age = sc.nextInt();
    if (age < 0 || age >150) throw Exception
}catch(Exception e){
    e.printStackTrace();
}
```

###### throw和throws的区别

* throw:指的是在方法之中人为抛出一个异常类对象(这个异常类对象可能是自己实例化,或者抛出已经存在的)
* throws:在方法的声明上使用,表示此方法在调用时必须处理异常,可以声明多个

## 原则

编译时异常Exception,给了几条禁止的原则，他们是：

* 不要直接忽略异常；
* 不要用try-catch包住过多语句；
* 不要用异常处理来处理程序的正常控制流；
* 不要随便将异常迎函数栈向上传递，能处理尽量处理。


## 异常处理流程

以java.lang.ArithmeticException为例查看继承架构:
```
java.lang.Object

  java.lang.Throwable

      java.lang.Exception

          java.lang.RuntimeException

              java.lang.ArithmeticException
```
所有的异常类都是Throwable的子类,Throwable下有两个子类

###### Error和Exception的区别?

* Error:指的是JVM错误,即:此时的程序没有执行,用户不能执行
* Exception:指的程序运行中产生的异常,用户可以处理

也就是说所谓的异常处理指的是所有的Exception以及它的子类异常

###### java中的异常处理流程

1.当程序在运行过程中出现了异常后,那么会由jvm自动根据异常的类型实例化一个与之匹配的异常类对象;

2.产生了异常对象之后,会判断当前的语句上是否存在有异常处理,如果没有异常处理,那么就交给JVM进行默认的异常处理,处理的方式:输出异常信息.而后结束程序的执行;

3.如果此时存在有异常的捕获操作,那么会由try语句来捕获产生的异常类实例化对象,而后与try以后的每一个catch语句进行比较,如果有符合的catch捕获类型,则使用当前的catch语句来进行异常的处理,如果不符合就继续向下匹配后面的catch;

4.不管最后异常处理是否能够匹配,那么都要向后执行,如果此时程序中存在有finally语句,如果有,就先执行finally语句,但是执行完毕后需要根据之前的catch匹配结果来决定如何执行,如果之前有匹配到catch语句,那么就继续执行finally之后的代码,如果之前没有匹配到相应的catch语句.那么就将此异常交给jvm处理,输出异常信息,结束程序执行

整个过程就好比方法重载一样,catch就好比方法名,根据catch后的参数进行类型匹配,但是所有java对象都存在有自动的向上转型的操作支持,如果说真的要匹配类型,简单的做法就是匹配Exception就够了

**两点说明:**

1.在编写多个catch捕获异常的时候,捕获范围大的异常一定要放在捕获异常范围小的后,否则程序编译报错

2.虽然直接捕获Exception比较方便,但是这样也不好,因为所有的异常都会按照同样一种方式进行处理;一些要求严格的项目里面,异常一定要分开处理.



## RuntimeException类 运行时异常

Java 提供了两类主要的异常：runtimeException 和 checkedException

**编译时异常**（checkedException）主要是指 IO 异常、SQL 异常等。对于这种异常，JVM 要求我们必须对其进行 cathc 处理，所以，面对这种异常，不管我们是否愿意，都是要 写一大堆的 catch 块去处理可能出现的异常。

**运行时异常**（runtimeException）的最大特征在于:程序在编译的时候不会强制性的要求用户处理异常。
这类异常的时候程序会由虚拟机接管。比如，我们从来没有去处理过 NullPointerException，而且这个异常还是最 常见的异常之一。

出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有 catch 块进行处理，到了最上层，如果是多线程就有 Thread.run()抛出，如果不是多线程 那么就由 main.run() 抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。

其实运行时异常的也是继承自 Exception，也可以用 catch 块对其处理，只是我们一般不处理罢了，也就是说，如果不对运行时异常进行 catch 处理，那么结果不是线程退出就是 主程序终止。

如果不想终止，那么我们就必须捕获所有可能出现的运行时异常。如果程序中出现了异常数据，但是它不影响下面的程序执行，那么我们就该在catch块里面将异常数据舍弃，然后记录日志。如果它影响到了下面的程序运行，那么还是程序退出比较好些。

###### Exceprion与RuntimeException的区别?

1.Exception是RuntimeException的父类;

2.使用过Exception定义的异常必须要被处理,而RuntimeException的异常可以选择性处理;

常见的RuntimeException:ArithmeticException,NullPointerException, ClassCastException


## 自定义异常

自定义异常类可以继承Exception(强制处理异常)或者RuntimeException(选择性处理异常

```
class AddException extends Exception{

    public AddException(String msg){

        super(msg);

    }

}
```