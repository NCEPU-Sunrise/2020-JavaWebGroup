#this关键字
    this可以看做一个变量，他的值是当前对象的引用
	this的用法：
    	当前类属性   this.成员变量  ->Person.java
        当前类方法（普通、构造）：this()、this.方法名称()
        	this()必须放在构造方法的首行
        	构造方法互相调用时请保留程序的出口，别形成死循环
	    
#static关键字
    之前的学习中，我们每new一次对象，就会创建出不同的对象，每个对象是独立存在的，所以它们的属性也就是成员变量是各自一份的。
    被static修饰的变量在类加载时即被初始化，且内存只被分配一次，因此其值在下次调用时仍维持上次的值；

    被static修饰的成员变量，成为静态变量，是属于”类级别“的公共变量。对于当前类的所有对象共享，只有一份。
        应用实例：当每个对象中都有一个值相同的成员变量，使用static声明---易于维护
                 统计、自动编号
    用static声明的方法为静态方法。在调用静态方法的时候，不会将对象的引用传递给它，所以在static方法中不能访问非static成员,而要创建对象，使用对象调用。
        ->静态方法不再针对于某个对象使用，所以不能访问非静态成员
        应用实例：不需要创建对象就可以调用的工厂方法或者工具方法。Java系统自带的Math、UUID、Class等常用的工具类就是用的这种方式。
                即这个方法我只是想调用一下，不需要牵扯工具类中的任何属性和变量，那就可以声明为静态方法

    通过对象引用或类名访问静态成员

    示例->code-Cat.java

    main方法也是加了static修饰的，也就是说我们程序在运行的时候，并没有创建对象，直接调用mian方法作为程序的入口。
    
#package import 
    为方便管理大型软件系统中数目众多的类，解决类的命名冲突问题，Java引入包（package）机制，提供类的多重命名空间。

    package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句则指定为无名包)。
	它的格式为:
		package pkg1[.pkg2[.pkg3...]];
	Java编译器把包对应于文件系统的目录管理，package语句中，用’.‘来指明包（目录）的层次，例如使用语句
		package com.sxt;
	则该文件中所以的类位于.\com\sxt目录下

	如果只写了package语句，却没有创建对应的文件夹目录，那么运行依然会出错。

	如果我们需要在其它类中使用有package声明的类，那么我们需要写上类的全限定名（包名+类名）以帮助系统准确找到指定的类来创建对象：

	package com.A;//1 
    public class Cat {
		//A公司的猫
	}
    
    package com.B;//2
    public class Cat {
		//B公司的猫
	} 
	public class Test {
		public static void main(String[] args) {
			com.A.Cat cat = new com.A.Cat();
		}
	}

	但是如果有大量的类需要创建对象，这样岂不是太麻烦了吗？于是我们创造了import关键字：
    package com.B;
	import com.A.Cat;
    //import com.A.*;//*引入所有com.A下的类
	public class Test {
		public static void main(String[] args) {
			Cat cat = new Cat();
		}
	}

	总结：
		- 如果想将一个类放入包中，在这个类源文件第一句话写package
		- 必须保证该类的class文件位于正确目录下
	    该类的源码可能会产生影响
	        删除或转移到另外的目录
		- 另外的类想访问的话:
	    	-写全名
			-引入
		    具体类名
		- 访问位于同一个包中的类不需要引入
		- 必须class文件的最上层包的父目录位于classpath下



