#对象转型
转型分两种：向上和向下。之前我们已经有过了解：int-->short short-->long 等等
    ·一个基类的引用类型变量可以“指向”其子类的对象。
    ·一个基类的引用不可以访问其子类对象新增加的成员（属性和方法）。
    ·可以使用引用变量instanceof 类名 来判断该引用型变量所“指向”的对象是否属于该类或该类的子类。
    ·子类的对象可以当作基类的对象来使用称作向上转型（upcasting)，反之称为向下转型( downcasting)

这里的转型包含着引用数据类型的转换：Dog-->Animal Animal-->Dog/Cat.. ...当别人把Dog传递给你的时候，你要注意它是被当作狗还是动物，如果是动物，那么狗独有的方法就不能被调用。

示例代码:code-Test.java

#动态绑定

上述代码增加了程序的可扩展性，但是还没有达到最好，怎么办呢？接下来我们就来学习：动态绑定。动态绑定也叫多态。指的是在执行期间，而非编译期间，判断所引用对象的实际类型，根据对象的实际类型来调用相应方法。

下面的案例中，根据Lady实际传入的数据类型来决定调用谁的什么方法。

示例代码：code-Lady.java

public class Test {
    public static void main(String args[]) {
        MyCat c = new MyCat("catname", "blue");
        Dog d = new Dog("dogname", "black");
        Lady l1 = new Lady("l1",c);
        Lady l2 = new Lady("l2", d);
        l1.myPetEnjoy();
        l2.myPetEnjoy();
    }
}

如果我们需要添加鸟类：Lady代码无需改变，这就是可拓展性。

#多态
·方法重载---实现静态多态性（编译时多态） 
    方法重载是指一个类中可以定义有相同的名字，但参数不同的多个方法。调用时，系统会根据不同的参数列表选择相对应的方法执行。
    返回类型可以相同也可以不同   
    示例程序：
        public class Test {
            //打印出来int a,b中的最大值
            void maxInt(int a, int b) {
                System.out.println(a>b?a:b);
            }
            //打印出来float a,b中的最大值
            void maxFloat(float a, float b) {
                System.out.println(a>b?a:b);
            }
            //打印出来double a,b中的最大值
            void maxDouble(double a, double b) {
                System.out.println(a>b?a:b);
            }
        }
        在Test.java中，明明相同的方法功能，参数不同，我们就需要写多个不同的方法，有没有可能用相同的方法名呢？
        这样我们就直接调用比较大小的方法，而不需要挑选是maxInt还是maxFloat或者其他了。
    修改后的程序（三个方法名字相同，但是参数列表不同，我们说这三个max方法是互相重载的）：
        public class Test {
            //打印出来int a,b中的最大值
            void max(int a, int b) {
                System.out.println(a>b?a:b);
            }
            //打印出来float a,b中的最大值
            void max(float a, float b) {
                System.out.println(a>b?a:b);
            }
            //打印出来double a,b中的最大值
            void max(double a, double b) {
                System.out.println(a>b?a:b);
            }
        }
    注意，重载跟返回值无关，如果我们定义以下方法：
        int max(int a, int b) {
                System.out.println(a>b?a:b);
        }
        ​
        void max(int a, int b) {
                System.out.println(a>b?a:b);
        }
    这两个方法不能同时存在，因为他们参数列表相同，编译器无法区分你需要使用的是哪一个方法。
·方法覆盖（方法重写）---实现动态多态性（运行时多态）
    重写是子类对父类的允许访问的方法的实现过程进行重新编写。
    重写的目的是为了使子类在继承父类方法后，调整继承下来的方法以便于更适应于自身的特征：狗，猫，大象虽然都继承于动物类的run方法，但是run方法内部实现细节各自不同。
    
    语法规则：
        ·在子类中可以根据需要对从基类中继承来的方法进行重写。
        ·重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。
        ·重写方法不能使用比被重写方法更严格的访向权限。
        ·返回类型必须一致 
        ·子类不能覆盖父类中声明为final或static的方法 
        ·子类必须覆盖父类中声明为abstract的方法，或继续声明为abstract 

    示例程序：(继承程序修改)

多态机制的三个特点（必要条件）：
1)存在继承关系
2)有重写
3)父类引用指向子类对象

使用多态实现思路：编写父类，编写子类，子类重写父类方法。
               运行时，使用父类的类型，子类的对象。
               向上转型，简单来说，允许将子类类型的指针赋值给父类类型的指针。

简言之，多态其实是在继承的基础上的。比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观狮子、参观猴子都是对的，但你不能说我们去参观卡车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。

好处：提高了程序的维护性，提高了程序的可扩展性。



    