面向对象设计的三个主要特征：
    封装性：内部的操作对外部而言不可见 -> 安全
    继承性：在已有结构的基础上继续进行功能的扩充->复用
    多态性：是在继承性的基础上扩充而来，指的是类型的转换处理
# 如何封装
    ·设置访问权限
        ->设置类的访问权限
            public：公有类，可以被其他类所访问和引用
                    在一个源程序中,public类只能有一个
            default：包访问性(同一包中的类可以访问)
        ->设置类成员的访问权限
            public：所有类均可访问
            protected：包访问性、本类及其子类的成员可以访问
            default：包访问性
            private：本类

# 继承
    Java中使用extends关键字实现类的继承机制，假设有个狗类（属于动物类）能跑，我们写狗的run方法，有个猫类（属于动物类）能跑，我们写猫的run方法，有个大象类（属于动物类）能跑，我们写大象的run方法... ...它们都是动物，我们就可以说：狗，猫，大象...都从动物继承，我们只需要将run方法写在动物类中定义一次，其他动物继承即可。
    
    Java中使用extends关键字实现类的继承机制，其语法规则为:
        [<modifier>] class < name>[extends < superclass>]{ ... ...}
        class Dog extends Animals{ }
    通过继承,子类自动拥有了基类(superclass）的所有成员（成员变量和方法），父类中声明为private的成员变量或方法子类不能继承。
    示例程序->code-ExtendTest.java

    ·Java只支持单继承，不允许多继承:
        一个子类只能有一个基类,一个基类可以派生出多个子类
    ·Object是所有类的超类（Object类比较特殊，之前我们讲过：java只支持单继承，而Object类是所有Java类的根基类，是金字塔的塔尖）
        toString();
        equals();
        了解：hascode();//每一个对象都有自己独一无二的哈希编码，根据这个编码，我们能确定对象的位置，但是java本身的哈希编码实现是有问题的，即：两个不同对象的哈希编码可能相同，而且概率不低
    ·继承后只能扩大类的访问权限，不能缩小访问权限

    继承中的构造方法:
    在构造子类对象的时候，内部会构造出一个父类对象，那么，这个父类对象从何而来呢？当然也是由父类的构造方法创造出来的。也就是说，在子类的构造方法中调用父类的构造方法。

    - >子类的构造的过程中必须调用其基类的构造方法。
    - >子类可以在自己的构造方法中使用super调用基类的构造方法,使用this调用本类的另外的构造方法
    - >如果子类的构造方法中没有显示地调用基类构造方法，则系统默认调用基类无参数的构造方法。
    - >如果子类没有写super调用父类的构造方法，那么系统将默认调用super();也就是父类默认的无参构造，如果父类没有无参构造，编译器就会报错。

    示例程序：code->TestSuperSub.java
    
super关键字
在java类中使用super来引用父类类的成分。

示例代码：code->TestInherit.java
class FatherClass {
    //成员变量
    public int value;
    //成员方法
    public void f(){
        value = 100;
        System.out.println("FatherClass.value="+value);
    }
}
class ChildClass extends FatherClass {
    //成员变量
    public int value;
    
    //成员方法 重写了父类方法
    public void f() {
        //调用父类的f()
        super.f();
        //补充自己的f()
        value = 200;
        System.out.println("ChildClass.value="+value);
        System.out.println(value);
        System.out.println(super.value);
    }
}


public class TestInherit {
    public static void main(String[] args) {
        //创建子类 cc存在于栈空间 new ChildClass()位于堆空间
        ChildClass cc = new ChildClass();
        cc.f();
    }
}

1) ChildClass cc = new ChildClass(); 
   这行代码执行：创建子类，cc存在于栈空间，new ChildClass()位于堆空间，
   堆空间中的子类对象中包含着一个父类对象，这个父类对象拥有value属性，同样子类对象本身也拥有一个value.

2) cc.f(); cc是子类对象，在子类对象中，this指代cc的对象本身，super指代父类对象。修改父类对象的value不会影响子类对象的value.

   ->picture-super内存分析

super和this都可以调用构造方法，super是子类调用父类的构造方法，this是调用本类的构造方法，两者不能同时出现